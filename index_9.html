
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <link rel="stylesheet" href="css/styles.css" type="text/css" media="screen"/>
    <link rel="alternate" type="application/rss+xml" title="ExoMemory" href="http://steveliles.github.com/rss.xml" />
    <link href='http://fonts.googleapis.com/css?family=Gochi+Hand' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono:700' rel='stylesheet' type='text/css'>
    <meta name="description" content="Thoughts on Java, GWT, programming, and other geek stuff"></meta>
    <script type="text/javascript" src="google-analytics.js"></script>
    <title>Steve Liles' Blog</title>
  </head>
  <body>
    <div>
      <div class="site-header">
        <div class="left">
          <a href="/index.html"><h1>ExoMemory</h1></a>
          <h2>Because I'll forget it if I don't write it down...</h2>
        </div>
        <div class="right">
	  <a rel="author" href="http://steveliles.github.com/about_me.html"><img src="images/lego.png"></a>
        </div>
      </div>
      <div class="nav">
        <span>
          <a rel="me" href="https://plus.google.com/105248011271585565954"><img src="http://www.google.com/images/icons/ui/gprofile_button-16.png" width="16" height="16"></a>
          <a rel="me" href="http://www.twitter.com/steveliles"><img src="http://twitter-badges.s3.amazonaws.com/t_mini-a.png" alt="Follow steveliles on Twitter"></a>
	  <a rel="me" href="http://uk.linkedin.com/in/steveliles"><img src="http://www.linkedin.com/img/webpromo/btn_in_20x15.png" width="20" height="15" alt="View my LinkedIn profile"></a>
	  <form action="http://www.google.com/search" method="get">
            <input type="hidden" name="q" value="site:steveliles.github.com">
            <input type="text" name="q" placeholder="search"></input>
          </form>
	  <a href="rss.xml"><img src="images/rss.png" width="16" height="16" alt="Subscribe to RSS feed"></a>
        </span>
      </div>
      <div class="content">
        <div class="main">
	    <div class="article" itemscope itemtype="http://schema.org/BlogPosting" inLanguage="en-GB" isFamilyFriendly="true" wordCount="536" description="A quick overview of pro's and con's of ElasticSearch vs SOLRCloud from some brief initial research into both">
              <span class="meta" itemprop="datePublished"><time datetime="2011-02-24">February 24, 2011</time></span>
              <a itemprop="url" href="elasticsearch_vs_solrcloud.html"><h1 itemprop="name" itemprop="headline">ElasticSearch vs SOLRCloud</h1></a>
	      <span itemprop="articleBody"><p>For an upcoming work project I need a scalable search platform - scalable to tens or hundreds of millions of documents (news articles), and millions of queries per day. We're a (mostly) Java shop, and have a lot of experience with Lucene, so two solutions that pique my curiosity are SOLRCloud (SOLR + ZooKeeper) and ElasticSearch.</p>

<h3>Initial Impressions - ElasticSearch</h3>

<p>ElasticSearch is impressive. Its clean, simple, and elegant. For those who are familiar with Compass, ElasticSearch can be considered as Compass 3.0 (quoting Shay Bannon, author of Compass). ElasticSearch has been under development for about 9 months at time of writing, and is currently at version 0.15. It appears to be very actively developed, with new features and fixes flowing steadily. </p>

<p>My main worry at this point is that there appears to be only one "resource" active on the project - Shay Bannon (@kimchy) himself, who seems to be architect, developer, documentation-writer, and a prolific commenter on forums.</p>

<h4>Noteworthy features include:</h4>

<ul>
<li>Document-oriented / Schema-free (JSON documents)</li>
<li>Store, retrieve, index and search multiple versions of documents</li>
<li>Self-hosting RESTful web-service api</li>
<li>Exposes the full power of lucene queries</li>
<li>Multiple Indexes in one cluster (described as Multi-Tenancy)</li>
<li>Built from the ground-up with scalability and distributed-operation in mind - supporting distributed search, automatic fail-over and re-balancing, with no single point of failure</li>
<li>Support for async write/backup to shared storage (Gateway, in ElasticSearch parlance)</li>
<li>"Percolator" (aka. prospective search)</li>
</ul>

<h3>Initial Impressions - SOLRCloud</h3>

<p>SOLR is a project from the same (Apache) stable as Lucene itself, and the projects have recently merged to some degree. SOLRCloud is an extension that integrates ZooKeeper with SOLR with the express aim of "enabling and simplifying the creation and use of Solr clusters."</p>

<p>SOLRCloud is described as "still under development", ie., not yet a GA release. </p>

<h4>Currently proclaimed features include:</h4>

<ul>
<li>Central configuration of the entire cluster</li>
<li>Automatic load-balancing and fail-over for queries</li>
<li>ZooKeeper integration for cluster coordination and configuration (not sure I would have listed that as a feature personally!)</li>
<li>I'll add that SOLRCloud is part of the SOLR code-base, and is being developed by core Lucene and SOLR committers including Mark Miller and Yonik Seeley. This can only be a good thing :). On top of all that, SOLR has been around for a good long time now, so it is battle-tested and there's lots of information available (including numerous books).</li>
</ul>

<p>That said, I still have two big worries about SOLRCloud:
* Setup/deployment just sounds fiddly - it is recommended not to deploy zookeeper embedded with SOLR (though I cannot find any explanation to back up that recommendation), which means you need both a ZooKeeper ensemble - multiple ZooKeeper instances - and a SOLRCloud ... er ... cloud.
* No GA release as yet, and no roadmap that I can find (this is the closest I got).</p>

<h3>Next Steps</h3>

<p>My next steps are to dive in to both technologies and really get to see which best suits our needs, and really how difficult these things are likely to be to manage in a medium/large-scale deployment.</p>
</span>

              <ul class="keywords">
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=ElasticSearch">ElasticSearch</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=SOLRCloud">SOLRCloud</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=Lucene">Lucene</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=Search">Search</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=Scalability">Scalability</a></li>
              </ul>
              <div style="clear:both"></div>

	        <a href="elasticsearch_vs_solrcloud.html">Comment on this post</a>

            </div>
	    <div class="article" itemscope itemtype="http://schema.org/BlogPosting" inLanguage="en-GB" isFamilyFriendly="true" wordCount="1,532" description="Ideas on how to implement progressive enhancement with Google Web Toolkit - part 3">
              <span class="meta" itemprop="datePublished"><time datetime="2011-02-15">February 15, 2011</time></span>
              <a itemprop="url" href="progressive_enhancement_with_gwt_part_3.html"><h1 itemprop="name" itemprop="headline">Progressive Enhancement with GWT, part 3</h1></a>
	      <span itemprop="articleBody"><p>UPDATE: Since writing this series I have published the source of <a href="http://steveliles.github.com/gwt_progressive.html"><code>gwt.progressive</code> at github</a>.</p>

<p>This is the third part in a series, following my thoughts on using GWT in SEO'able web applications. The other parts in the series are <a href="progressive_enhancement_with_gwt_part_1.html">part 1</a> and <a href="progressive_enhancement_with_gwt_part_2.html">part 2</a>.</p>

<p>In my previous posts I described an idea for progressive enhancement using GWT -  "activating" server-generated html, to combine GWT goodness with an SEO friendly server-generated website, and my findings after some initial trials. </p>

<p>One of the problems I described in that second post was that it would be very difficult to work with these widgets if nested widgets could not be automatically (or at least easily) bound to fields within this widget.</p>

<p>After a little playing around and learning about GWT Generators I now have what seems like a nice solution, using a Generator to do almost all of the donkey work. Think of it like UiBinder, but with the templates provided at runtime (courtesy of the server). Here's an example class that automatically binds sub-widgets - an Image in this case - to a field of that class:</p>

<pre><code>public class MyWidget extends Widget {

    interface MyActivator extends ElementActivator&lt;MyWidget&gt; {}
    private static MyActivator activator = GWT.create(MyActivator.class);

    @RuntimeUiField(tag="img", cssClass="small") Image small;

    public MyWidget(Element anElement) {
        // this will set our element and bind our image field.
        setElement(activator.activate(this, anElement));

        // now we can play with our fields.
        small.addClickHandler(new ClickHandler() {
            public void onClick(ClickEvent aEvent) {
                Window.alert("clicked!");
            }
        });
    }
}
</code></pre>

<p>This class will bind onto any html that has an image tag somewhere in its inner-html, for example:</p>

<pre><code>&lt;div&gt; &lt;!-- Say our MyWidget is bound here --&gt;
  &lt;div&gt;
    &lt;span&gt;
          &lt;!-- will be bound to our Image widget --&gt;
      &lt;img class="small" src="/images/image.jpg"&gt;
    &lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>Anyone familiar with UiBinder will recognize the pattern I've used for the "activator":</p>

<ul>
<li>Extend an interface with no methods
<code>interface MyActivator extends ElementActivator&lt;MyWidget&gt; {}</code></li>
<li>GWT.create() an instance of that interface
<code>private static MyActivator activator = GWT.create(MyActivator.class);</code></li>
<li>Then use it to initialize your widget
<code>setElement(activator.activate(this, anElement));</code></li>
</ul>

<p>The nice thing about this is we can automatically bind as many widgets as we like onto various sites within the inner-html of our current widget's element. It doesn't mess with the structure (unless you explicitly do so after the binding is done for you), and you can have as much other html within the elements as you like - it will just be left alone, which gives your designers the flexibility to change the layout quite a lot without necessarily needing to re-compile your GWT code. </p>

<p>Currently I have my generator set up to allow your widgets to bind to a choice of tag-name or css-class or both, for example:</p>

<pre><code>// bind to the first &amp;lt;div&gt; found by breadth-first 
// search of child elements
@RuntimeUiField(tag="div") Label label;

// bind to first element with class="my-widget" 
// found by breadth-first search
@RuntimeUiField(cssClass="my-widget") Label label;

// bind to first &amp;lt;div&gt; with class="my-widget" 
// found by breadth-first search
@RuntimeUiField(tag="div", cssClass="my-widget") Label label;
</code></pre>

<p>Notice in my examples so far I'm binding standard GWT widgets onto the nested elements. This works for the elements I've used in these examples because they all have a <code>public static Type wrap(Element anElement)</code> method which allows those widgets to be bound onto elements that are already attached to the DOM.</p>

<p>It is also possible to bind widgets of your own making in one of two ways:</p>

<ol>
<li>Create a wrap method like 
<code>public static MyWidget wrap(Element anElement)</code></li>
<li>Create a single-argument public Constructor that accepts an <code>Element</code> as its argument.</li>
</ol>

<p>Activate-able widgets can be nested within other such widgets - with no limits that I am aware of so far - and it is also possible to assign nested widgets to a List field in the enclosing widget, like this:</p>

<pre><code>@RuntimeUiField(tag="img") List&lt;Image&gt; images;
</code></pre>

<p>This will search recursively for any <code>&lt;img&gt;</code> tags inside the enclosing widget's element and bind them all to Image widget's that will be added to the List. The current limitations here are that the List must be declared either as List or ArrayList, and parameterized with a concrete type that meets the criteria defined above (i.e. has a static <code>wrap(Element)</code> method, or a single-arg constructor that takes an <code>Element</code> as the argument).</p>

<p>A remaining question is how to bind the outer-most Widget. Currently I'm doing that using the DOM scanning code I wrote during earlier experiments and which I'm also using in the automatic scanning process set up by the Generator. For example to find the outer-most widgets and kick off the binding process I have something like this in my EntryPoint:</p>

<pre><code>public void onModuleLoad() {
    List&lt;MyWidget&gt; _myWidgets = new ArrayList&lt;mywidget&gt;();
    for (Element _e : Elements.getByCssClass("outer-most-widget")) {
        new MyWidget(_e);
    }
    // do stuff with our widgets ...
}
</code></pre>

<p>I think of this as very similar to the RootPanel situation - "normal" GWT apps kick off by getting a RootPanel(body tag) or RootPanel's (looked up by id), to which everything else is added. It would be nice to hide away some of that scanning code inside a "top-level" widget - much like RootPanel does for the normal case. I can imagine this might look something like:</p>

<pre><code>public void onModuleLoad() {
    Page _page = Page.activate();
    _page.doStuffWithWidgets();
    // ...
}
</code></pre>

<p>I still have lots of things to figure out and questions to answer, for example:</p>

<ul>
<li>What's the performance like when binding many hundreds of widgets?</li>
<li>How will this really work when I make ajax requests for more data? (should I make ajax requests for html snippets which I add to the DOM and then bind onto, or switch to json for ajax requests and make my widgets able to replicate themselves from an initial html template?)</li>
<li>What's the best way to divide labour between developers and designers, and for them to organize their interaction? (Ideally I'd like there to be something of a cycle between them, where the designer can rough-out a page design, agree the componentisation with the developer, the developer knocks out some components and a build which the designer can use to activate their static designs, add fidelity, work on other pages with the same components, etc).</li>
<li>Where is the sweet-spot between creating high-fidelity html server-side and decorating it client-side using GWT? Should the GWT components really be just for adding dynamism, or is it a good idea to use them to build additional html sweetness? - I mean the server could dish out html that is more of a model than a view (just enough "view" to satisfy SEO), and the GWT layer acts as a client-side controller and view (<a href="http://www.thinserverarchitecture.com/home">SOFEA/TSA</a> with a nod to SEO).</li>
</ul>

<p>I'll try to keep posting as I work things out.</p>

<p>This probably belongs in a separate post, but with reference to that last point on TSA (Thin Server Architecture) - the working group list the following points to define the concept:</p>

<blockquote>
  <ol>
  <li>Do not use server-side templating to create the web page.</li>
  <li>Use a classical and simple client-server model, where the client runs in the browser.</li>
  <li>Separate concerns using protocol between client and server and get a much more efficient and less costly development model.</li>
  </ol>
</blockquote>

<p>I'm right behind them on (2) and (3), and also on (1) for "enterprise" apps where SEO is a non-goal. However, for an app that needs SEO, (1) is a deal-breaker, so I'd offer this alternative 1st rule instead:</p>

<ol>
<li>Use server-side templating to produce a model for the client to consume which minimally satisfies the needs of SEO.</li>
</ol>
</span>

              <ul class="keywords">
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=ajax">ajax</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=designer">designer</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=gwt">gwt</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=progressive enhancement">progressive enhancement</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=SEO">SEO</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=SOFEA">SOFEA</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=TSA">TSA</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=UiBinder">UiBinder</a></li>
              </ul>
              <div style="clear:both"></div>

	        <a href="progressive_enhancement_with_gwt_part_3.html">Comment on this post</a>

            </div>
	    <div class="article" itemscope itemtype="http://schema.org/BlogPosting" inLanguage="en-GB" isFamilyFriendly="true" wordCount="110" description="Describes the process of installing fonts in Ubuntu Linux">
              <span class="meta" itemprop="datePublished"><time datetime="2011-02-12">February 12, 2011</time></span>
              <a itemprop="url" href="installing_fonts_in_ubuntu.html"><h1 itemprop="name" itemprop="headline">Installing fonts in Ubuntu</h1></a>
	      <span itemprop="articleBody"><p>Installing fonts in ubuntu is very easy these days - just open a ttf file and you are presented with a nice sample of the font (quick brown fox style), and a button in the bottom right corner to install the font.</p>

<p>Nice'n'easy, but you're not quite done yet. You'll definitely need to restart running apps before the font becomes available to them, and quite possibly you'll need to rebuild the font cache, which you can do by rebooting (hah!) or:</p>

<pre><code>sudo fccache -fv
</code></pre>

<p>btw., check out <a href="http://en.wikipedia.org/wiki/File:EurostileSpec.svg">Eurostile</a>. Its about 50 years old, but nonetheless is one of the most gorgeous fonts i've ever seen.</p>
</span>

              <ul class="keywords">
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=fonts">fonts</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=ubuntu">ubuntu</a></li>
              </ul>
              <div style="clear:both"></div>

	        <a href="installing_fonts_in_ubuntu.html">Comment on this post</a>

            </div>
	    <div class="article" itemscope itemtype="http://schema.org/BlogPosting" inLanguage="en-GB" isFamilyFriendly="true" wordCount="738" description="Ideas on how to implement progressive enhancement with Google Web Toolkit - part 2">
              <span class="meta" itemprop="datePublished"><time datetime="2011-02-12">February 12, 2011</time></span>
              <a itemprop="url" href="progressive_enhancement_with_gwt_part_2.html"><h1 itemprop="name" itemprop="headline">Progressive Enhancement with GWT, part 2</h1></a>
	      <span itemprop="articleBody"><p>UPDATE: Since writing this series I have published the source of <a href="http://steveliles.github.com/gwt_progressive.html"><code>gwt.progressive</code> at github</a>.</p>

<p>This is the second part in a series, following my thoughts on using GWT in SEO'able web applications. The other parts in the series are <a href="progressive_enhancement_with_gwt_part_1.html">part 1</a> and <a href="progressive_enhancement_with_gwt_part_3.html">part 3</a>.</p>

<p>Since my earlier post, I spent a little time (only a few hours really, so far) trying a few things out. Here's a smattering of things I learned...</p>

<p>Scanning for elements and binding widgets onto them is easy. Making those widgets behave just like widgets in any normal GWT app needs a little more work.</p>

<h3>Who's the daddy?</h3>

<p>One big problem to get around is that normally GWT widgets are attached via a hierarchy of other widgets (parents) leading back to the RootPanel, whereas when you bind onto some arbitrary element that is already on the page you don't get this hierarchy for free.</p>

<p>When widgets are added to a parent widget some magic happens to set up things like the eventing system. Without that magic you can add as much event-handling plumbing as you like, but it won't work because your widget isn't wired into the eventing system.</p>

<p>Actually getting around this is not all that difficult. Simply invoking onAttach() will wire up your widget, though its a little unpleasant to have to do that.</p>

<p>Another problem with the lack of hierarchy is, well, there's no hierarchy. Things that you would normally do in GWT widgets - like adding, removing or replacing child widgets - gets a little trickier. If you want to use the technique recursively (and why wouldn't you?), you need to allow widgets to bind to elements inside other widgets without causing them to be removed from and re-attached to the DOM, but crucially you still need to add them as 'logical' children of the parent widget, otherwise the parent knows nothing about the child widgets and can't do any of those "normal" operations with them.</p>

<p>To do that there are two problems to overcome:</p>

<ol>
<li>The parent needs to have the children added to it, so that the set of child widgets is known and available for manipulation (say by extending ComplexPanel and using the getChildren() method).</li>
<li>Some of the child widgets might need hard, typed references in the parent widget to allow direct manipulation of the child widget - just like in a "normal" GWT widget you would keep a reference to the Button you added in the constructor in order that you can bind ClickHandler's to it or toggle its enabled-ness.</li>
</ol>

<p>Point 1 is easily solved - any widget that wants to play this way needs to support adding other widgets without triggering an attachment to the current element. When you add a normal child widget to a normal  parent widget, the child is detached from its current parent - logically and physically - so that its html element is actually inserted into the DOM under the parent's element. This is not what we want when binding onto a template - we just want the logical attachment step, so we need to support an add method something like:</p>

<pre><code>public void logicalAdd(Widget aWidget) {
  getChildren().add(aWidget);
  adopt(aWidget);     
}
</code></pre>

<p>I've yet to try to solve point 2. So far I've built:</p>

<ul>
<li>Tools to help with scanning for elements to bind to, and then binding the right widget.</li>
<li>Plumbing to allow recursively binding widgets with logical hierarchy intact (point 1 above).</li>
<li>An example that binds widgets recursively - an outer container, an inner container, and a bunch of widgets inside that are manipulated by the inner container.</li>
</ul>

<p>I'll try to update the post with an example at some point. Meanwhile my next challenge is to solve point 2 such that widget developers can build their widgets in a fairly typical GWT way.</p>

<p>As an aside, I lay awake for a while last night pondering the ability to give designers a client-side templating system, where they can write the html for a component once (declaring it to be a template, which may include recursive binding points for GWT-activated widgets) and then re-use it elsewhere within their html by reference to the template. I'm sure this would be possible, though its utility might extend only to mock-ups.</p>
</span>

              <ul class="keywords">
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=ajax">ajax</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=designer">designer</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=gwt">gwt</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=progressive enhancement">progressive enhancement</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=SEO">SEO</a></li>
              </ul>
              <div style="clear:both"></div>

	        <a href="progressive_enhancement_with_gwt_part_2.html">Comment on this post</a>

            </div>
	    <div class="article" itemscope itemtype="http://schema.org/BlogPosting" inLanguage="en-GB" isFamilyFriendly="true" wordCount="1,771" description="Ideas on how to implement progressive enhancement with Google Web Toolkit - Part 1">
              <span class="meta" itemprop="datePublished"><time datetime="2011-01-30">January 30, 2011</time></span>
              <a itemprop="url" href="progressive_enhancement_with_gwt_part_1.html"><h1 itemprop="name" itemprop="headline">Progressive Enhancement with GWT, part 1</h1></a>
	      <span itemprop="articleBody"><p>This is the first part in a series, following my thoughts on using GWT in SEO'able web applications. The other parts in the series are <a href="progressive_enhancement_with_gwt_part_2.html">part 2</a> and <a href="progressive_enhancement_with_gwt_part_3.html">part 3</a>.</p>

<p>GWT Is a superb framework for developing complex, componentized html &amp; javascript widgets.  You can have your cake and eat it:</p>

<ul>
<li>Drop down into native javascript as and when you feel the need</li>
<li>Integrate easily with native js components and libraries</li>
<li>Use GWT components relatively easily from native javascript</li>
<li>Create super-condensed, fast, platform-specific code, easily</li>
<li>All the benefits of Java's static type-system, packages, and tooling to manage and refactor your code</li>
<li>It is very tempting to go for an all-out GWT user-interface, which is great if what you want is a super-snazzy Rich-Internet-Application which packs down into very small and extremely cacheable js bundles that fetch data asynchronously from the server, and you don't mind re-compiling your user-interface to make even a very small change.</li>
</ul>

<p>It isn't so great when:</p>

<ul>
<li>You need to expose the content of your site for search-engines to index (The SEO Problem).</li>
<li>You want to leverage the html and css skills of your UI designers, and to be able to generate more flexible layouts without requiring a re-compile (The Design Problem).</li>
</ul>

<h2>The SEO Problem</h2>

<p>To a search engine, GWT apps just look like a big fat lump of dense javascript. Nothing to see here, move along. Its a similar problem for any web-app that uses ajax to collect data from the server, but the problem is magnified with GWT due to the fact that the entire application tends to present as a large lump of dense javascript, whereas many other ajax technologies typically involve some amount of server-side content rendering that can make the site at least partially visible to crawlers.</p>

<p>Google have a recommendation for how to get around the problems of SEO for ajax applications, which entails a special url form and the creation of "html snapshots" - effectively a parallel, ajax-disabled site that the crawler can index. This seems to me to be a workable but irritating solution that involves doing a lot of extra work just to allow a search engine to crawl the site. Its effectively just a Google-approved cloaking method. Also it isn't clear to me whether any other search engines than Google support this approach.</p>

<h2>The Design Problem</h2>

<p>Don't get me wrong, its not as bad as all that. You can, of course, leverage your UI/UX designer's talents when building GWT apps. They can produce designs that the GWT developers base their components on, and with UIBinder the html fragments produced by a designer can be used in large chunks, but there is always some disconnect between what the designers produce and what is actually output by the application - usually because there is a developer translating the designer's work into GWT components.</p>

<p>In retrospect, having built a number of "monolithic" GWT applications, it seems to me that what we're missing is a way to step back just a little from the "GWT does everything" mind-set, and instead to leverage GWT where it is best suited, and something a little more flexible where GWT can be too restrictive - for example when laying out high level components on a page it would be advantageous to be able to escape from the restrictions of having to compile that page layout into js, and instead work at the level of straight-forward declarative markup.</p>

<h2>Introducing "GWT-Activated Pages"</h2>

<p>How can we solve these two issues? One idea I've been toying with, is to use GWT for progressive enhancement of simple html + css, and goes as follows:</p>

<p>Rather than try to build two almost parallel versions of your application (one for SEO, one for real users), why not build one with a layered approach that allows graceful degradation for browsers with javascript disabled (of which search-engines could be considered a sub-set).</p>

<p>The base-layer that non-javascript browsers would render, and which search-engines would see, would be generated  by some typical server-side technology - php, jsp, struts, jfaces, ... take your pick. This would build a "wireframe" of your page, giving it a basic shape and layout, and filling in some starter content. The markup would ideally be meaningful, in the sense that headings would appear in <code>&lt;h1&gt;</code> tags to indicate that they are headings, rather than to give them any particular styling.</p>

<p>This base layer would be something that designers could work on directly, including any and all css styling.</p>

<p>The second layer would be a set of GWT widgets that "activate" or progressively enhance the page, by scanning the DOM for certain signs that denote activateable sections of markup. When the base page loads, GWT widgets search for elements to bind themselves to. When a widget finds such an element it binds to it and "activates" it. Activation could mean anything from completely changing the html markup, to binding event-listeners, to handling interaction with ajax data loading from the server.</p>

<p>Here's a simple example "base" layer:</p>

<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;Page Header&lt;/h1&gt;
    &lt;ol class="gwt-navigation-widget"&gt;
      &lt;!-- the listitems are generated server side --&gt;
      &lt;li&gt;&lt;a href=".."&gt;Home&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=".."&gt;News&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=".."&gt;Videos&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=".."&gt;Photos&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=".."&gt;About&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ol class="gwt-news-ticker-widget"&gt;
      &lt;!-- the listitems are generated server side --&gt;
      &lt;li&gt;News story 1&lt;/li&gt;
      &lt;li&gt;News story 2&lt;/li&gt;
      ...
      &lt;!-- this last listitem gives a link that 
               a search engine can follow to get more data --&gt;
      &lt;li&gt;&lt;a href=".."&gt;older stories&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;


    &lt;script type="text/javascript" language="javascript" 
                src="widgets/navigation-widget.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" language="javascript" 
                src="widgets/news-ticker-widget.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Notice the elements with css class-names prefixed with "gwt-". These are the signs that our gwt widgets will be looking for in order to know which elements they should activate.</p>

<p>As you probably guessed, the navigation widget would detect any elements with a class-name matching "gwt-navigation-widget", while the news-ticker will search for "gwt-news-ticker-widget".</p>

<p>OK, so what do we get for our troubles? Well, several things potentially:</p>

<ul>
<li>One request to the server to get our initial page full of data (rather than multiple widgets requesting async loading of little chunks of data)</li>
<li>A page that contains the data and is search-engine friendly, allowing pages deep within your app to indexed by search-engines</li>
<li>A very clear separation of widgets and page layout, allowing you more flexibility to change the page layout without GWT re-compile</li>
<li>Flexibility in dividing work between designers and developers:
<ul><li>designers can focus on the design-heavy html and css work, and the overall page layout</li>
<li>developers can focus on interaction with the server, complex widget behaviour, etc.</li></ul></li>
<li>Upon finding an element to bind to, the widget would:
<ul><li>Examine the content of the element - this will very likely be the source of its initial configuration and/or data-set, and also might include some information about how to load more content, as in the news-ticker example whose last <li> is a link to "older stories". I'm sure it would be a good idea to make this even more explicit, but like I said this is supposed to be a simple example :)</li>
<li>Replace or modify the content of the element - perhaps the widget displays a very complicated UI, so it removes the html and replaces it with something nifty that it generates, or maybe it just adds some decoration in the form of small visible changes, or perhaps it binds a bunch of event handlers to do neat tricks like adding gesture handling for touch-screen users. It seems that it would be perfectly possible to bind widgets inside widgets in this way, although at some point you would probably want to control the binding order such that an outer widget binds before an inner one. One way to do this might be to have a page-activator that seeks elements that want to be activated, and which all widgets are registered with. This could be described nicely as a Pattern.</li></ul></li>
</ul>

<p>In my simple example I showed the scripts being loaded separately, just for clarity, but I'm sure you wouldn't want to load each widget as a separate script - that would lose a good chunk of GWT's advantage. Rather, the whole widget-set could be loaded as one script, cached forever, and used all over.</p>

<p>Now, if you want to see an example of GWT-activated pages at work, just take a look at my older post on <a href="3d_graphics_using_the_html5_canvas.html">rendering 3D Rubiks Cubes with GWT and HTML5 Canvas</a>, where the rubik's cubes are rendered by a gwt widget that "activates" a <code>&lt;div&gt;</code> element containing the configuration for the cube.</p>

<p>OK, but what are the down-sides? Here's a few...</p>

<ul>
<li>Compiler no longer has visibility across the whole UI.</li>
<li>Messaging between components becomes more difficult (but not impossible). This has its advantages too - it forces low coupling. Messaging via OpenAjax Hub or similar would be worth considering.</li>
<li>It's more work - in some naive ways - than a straight-out GWT UI, and many would argue why bother to use GWT at all if you need SEO (depends on your skill-set and the complexity of the components you're building in my view).</li>
<li>I'm sure that there are others which I'm currently blind to ... I need to try to build some more complex and interesting examples to find these out.</li>
</ul>

<p>tl;dr ?</p>
</span>

              <ul class="keywords">
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=ajax">ajax</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=designer">designer</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=gwt">gwt</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=seo">seo</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=progressive enhancement">progressive enhancement</a></li>
              </ul>
              <div style="clear:both"></div>

	        <a href="progressive_enhancement_with_gwt_part_1.html">Comment on this post</a>

            </div>
        </div>
        <div class="sidebar">
          <div>
            <div class="twitter-feed" show="4" account="steveliles">
              <h5>Recent Tweets</h5>            
              <ul class="tweets">
                <li class="tweet-template" style="display:none">        
                  <span class="text"></span>&nbsp;<span class="date" format="yyyy"></span>
                </li>
              </ul>
              <a href="https://twitter.com/steveliles" class="twitter-follow-button" data-show-count="false">Follow @steveliles</a>
	      <script src="//platform.twitter.com/widgets.js" type="text/javascript"></script>
            </div>
          </div>
          <div>
            <a href="article-archive.html"><h5>Recent Posts</h5></a>
            <ul>
                <li><a href="comparing_java_xml_parsing_mechanisms.html">Comparing Java XML parsing mechanisms</a><span class="date"> - Apr 10, 2012</span></li>
                <li><a href="xml_parsing_in_android.html">XML Parsing in Android</a><span class="date"> - Apr 05, 2012</span></li>
                <li><a href="android_s_asynctask.html">Android's AsyncTask</a><span class="date"> - Mar 26, 2012</span></li>
                <li><a href="returning_a_result_from_an_android_activity.html">Returning a result from an Android Activity</a><span class="date"> - Mar 03, 2012</span></li>
                <li><a href="custom_fonts_in_android.html">Custom fonts in Android</a><span class="date"> - Feb 20, 2012</span></li>
            </ul>
            <a href="article-archive.html">Older posts...</a>
          </div>
        </div>
      </div>
      <div class="nav">
        <div class="links">
          <div class="prev"><a title="previous" href="index_8.html">Newer Posts</a></div>
          <div class="next"><a title="next" href="index_10.html">Older Posts</a></div>
        </div>
      </div>
    </div>
    <script type="text/javascript" language="javascript" src="blog/blog.nocache.js"></script>
  </body>
</html>

