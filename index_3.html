
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <link rel="stylesheet" href="css/styles.css" type="text/css" media="screen"/>
    <link rel="alternate" type="application/rss+xml" title="ExoMemory" href="http://steveliles.github.com/rss.xml" />
    <link href='http://fonts.googleapis.com/css?family=Gochi+Hand' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono:700' rel='stylesheet' type='text/css'>
    <meta name="description" content="Thoughts on Java, GWT, programming, and other geek stuff"></meta>
    <script type="text/javascript" src="google-analytics.js"></script>
    <title>Steve Liles' Blog</title>
  </head>
  <body>
    <div>
      <div class="site-header">
        <div class="left">
          <a href="/index.html"><h2>Because I'll forget it if I don't write it down...</h2></a>
        </div>
        <div class="right">
	  <a rel="author" href="http://steveliles.github.com/about_me.html"><img src="images/lego-small.png"></a>
        </div>
      </div>
      <div class="nav">
        <span>
          <a rel="me" href="https://plus.google.com/105248011271585565954"><img src="https://ssl.gstatic.com/images/icons/gplus-16.png" width="16" height="16"></a>
          <a rel="me" href="http://www.twitter.com/steveliles"><img src="http://twitter-badges.s3.amazonaws.com/t_mini-a.png" alt="Follow steveliles on Twitter"></a>
	  <a rel="me" href="http://uk.linkedin.com/in/steveliles"><img src="http://www.linkedin.com/img/webpromo/btn_in_20x15.png" width="20" height="15" alt="View my LinkedIn profile"></a>
	  <form action="http://www.google.com/search" method="get">
            <input type="hidden" name="q" value="site:steveliles.github.com">
            <input type="text" name="q" placeholder="search"></input>
          </form>
	  <a href="rss.xml"><img src="images/rss.png" width="16" height="16" alt="Subscribe to RSS feed"></a>
        </span>
      </div>
      <div class="content">
        <div class="main">
	    <div class="article" itemscope itemtype="http://schema.org/BlogPosting" inLanguage="en-GB" isFamilyFriendly="true" wordCount="400" description="Just finished converting dsl4xml to work from either pull (fast for servers) or SAX (fast on Android). Here's the perforamnce chart...">
              <span class="meta" itemprop="datePublished"><time datetime="2012-04-23">April 23, 2012</time></span>
              <a itemprop="url" href="sax_based_dsl4xml_for_android.html"><h1 itemprop="name" itemprop="headline">SAX based dsl4xml for Android</h1></a>
	      <span itemprop="articleBody"><p>I just checked in a <a href="https://github.com/steveliles/dsl4xml/blob/master/src/main/java/com/sjl/dsl4xml/SAXDocumentReader.java">SAX parser based version of dsl4xml</a> to github, and finally got a chance to run the perf tests on an Android device. This is how it looks:</p>

<div style="width:590px; height:300px;" id="sax_dsl4xml_chart_div"></div>

<p>Notice that while it loses about 15% on raw SAX parsing, it still provides approximately an order of magnitude greater throughpout than the next best (raw pull parsing). And of course, its damn easy to write <em>readable</em> unmarshalling code with :)</p>

<p>I also added SimpleXML parsing to my performance tests - it ties for last place (performance-wise) with W3C DOM parsing. Arguably it is more readable and requires less code than the others, though personally I'm not a huge fan.</p>

<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript">
      google.load("visualization", "1", {packages:["corechart"]});
      google.setOnLoadCallback(drawCharts);

      function drawCharts() {
        drawSAXdsl4xmlChart();
      }

      function drawSAXdsl4xmlChart() {

        var data = new google.visualization.DataTable();
        data.addColumn('string', 'Concurrency (threads)');


data.addColumn('number', 'W3C DOM');
data.addColumn('number', 'SAX');
data.addColumn('number', 'Pull');
data.addColumn('number', 'dsl4xml (pull)');
data.addColumn('number', 'dsl4xml (SAX)');
data.addColumn('number', 'SJXP');
data.addColumn('number', 'SimpleXML');

        data.addRows([

['1',2.3990626431189757,43.064527743674304,3.5096192666862467,3.1076837111373043,29.861563321354247,2.4664573717826044,2.3909004146918598],
['2',3.8097945346845243,69.65230695343173,6.033185779344725,5.719798415469687,54.390135966806106,4.19575915770385,3.927812341410011],
['3',3.6368249512540114,71.39012835438209,5.537694525649179,4.886205168164367,58.04773944850799,3.8392278830888653,3.5690149046875117],
['4',3.6586810559054896,78.02354281756789,5.476464455883683,4.989187889389914,60.89659425282844,4.014151778333453,3.6487355420874175]
        ]);

        var options = {
          title: 'Parsing Throughput (higher is better)',
          hAxis: { title: 'Concurrency (threads)' },
          vAxis: { title: 'Throughput (docs/sec)' }
        };

        var chart = new google.visualization.ColumnChart(document.getElementById('sax_dsl4xml_chart_div'));
        chart.draw(data, options);

      }
</script>
</span>

              <ul class="keywords">
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=java">java</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=xml">xml</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=parse">parse</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=dsl">dsl</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=perforamnce">perforamnce</a></li>
              </ul>
              <div style="clear:both"></div>

	        <a href="sax_based_dsl4xml_for_android.html">Comment on this post</a>

            </div>
	    <div class="article" itemscope itemtype="http://schema.org/BlogPosting" inLanguage="en-GB" isFamilyFriendly="true" wordCount="2,068" description="I'm so fed up with the Google Play comments system. How can they have got it so wrong?">
              <span class="meta" itemprop="datePublished"><time datetime="2012-04-21">April 21, 2012</time></span>
              <a itemprop="url" href="android_market_comments_severe_fail.html"><h1 itemprop="name" itemprop="headline">Android Market Comments - Severe Fail</h1></a>
	      <span itemprop="articleBody"><p>I'm so fed up with the Google Play comments and rating system. How can they have got it so wrong? Comments and user-ratings are a bad system to start with, but Google's system is broken beyond belief.</p>

<h3>Comment/Rating is a broken idea</h3>

<p>Commenting and rating systems are a bad idea to begin with. They pander to the extremes no matter what the subject under comment.</p>

<p>Check any app - <em>any app</em> - on the market: I defy you to find <em>one</em> that is not overwhelmingly rated 1 or 5 stars. Why? Because most people between the two extremes don't care enough or can't be bothered to rate an app.</p>

<p>That leaves the big fans who love the apps unquestionably but, bless 'em, unhelpfully ("&#9733;&#9733;&#9733;&#9733;&#9733; Love this app"), and the haters ("&#9733;&#9734;&#9734;&#9734;&#9734; Gross! sucks! don't download!").</p>

<p>The big fans are wonderful, but not helpful, but neither are they being destructive. The haters though, they really get to me. I <em>want</em> my apps to be good. I <em>want</em> them to work for everyone. I <em>want</em> them to be liked. I feel it <em>really personally</em> when my app gets a bad rating. I shouldn't, everyone tells me, but I can't help it - I'm invested in my work.</p>

<p>I've put a lot of time and effort into this thing - poured myself into it. A lot of that time I've given away free. Gratis. No charge. The "pro" version is the price of a newspaper that you'd read once and throw away.</p>

<p>If you download, don't like, &#9733;&#9734;&#9734;&#9734;&#9734; and walk away, I'm stuck with a bad rating that I can do <em>nothing</em> about, and its cost you <em>nothing</em> (Google Play allows a refund within a couple of hours of the download). </p>

<p>Please don't misunderstand me - I'm not railing against the people who comment and rate negatively - everyone is entitled to an opinion. The problem is the system which Google have created seems designed to make life difficult for app developers, and frustrating for users.</p>

<p>Negative commenters seem to fall into a few categories:</p>

<h4>The Unwittingly Unhelpful</h4>

<blockquote>
  <p>&#9733;&#9734;&#9734;&#9734;&#9734; <em>N. O'Tunreasonable</em> on April 20th, 2012 (Motorola shit-hot-superphone-II with version 2.0.1)</p>
  
  <p>"Doesn't work on Motorola shit-hot-superphone-II. FIX IT OR REFUND ME!".</p>
</blockquote>

<p>Dude, I'd love to fix it. No really, I would! Ask any one of the dozen or so people who've emailed or tweeted me about a problem and who got a response within hours and a fix within two days at most (best I can do on a personal project - I have a day job!).</p>

<p>Unfortunately I don't have a Motorola shit-hot-superphone-II (its always Motorola, why is that? Oh, occasionally its an HTC, but nearly always Motorola. Curse them). </p>

<p>It works great on my Samsung's, including the Galaxy mini that cost Â£50 in Tesco. No new crash reports or freezes in my developer console. How in the living hells do you expect me to FIX IT or, for that matter, to refund you? <em>I do not know who you are</em> because Google anonymise you!</p>

<p>I don't blame these guys actually - they rightly expect the app to work, and equally they expect a commenting system to allow some kind of conversation. Unfortunately, the Android eco-system is fragmented to hell and back, bugs are a universal truth of software, and Play's commenting system does not allow threaded responses and does not give the developer access to the commenters identity.</p>

<p>The first two I can handle - fragmentation requires more work, and bugs can be fixed, but I <em>need</em> to be able to communicate with commenters or I can't help them. I'm looking at you Google. With beetled brows.</p>

<h4>The Blackmailer</h4>

<p>Uses the power of a bad rating to demand whatever features he feels the app should have before benificently conferring his generous 5 stars.</p>

<blockquote>
  <p>&#9733;&#9734;&#9734;&#9734;&#9734; <em>Dick Dastardly</em> on April 16th, 2012 (HTC Wonderful with version 2.0.1)</p>
  
  <p>"Great app, will rate 5* when you add XYZ feature"</p>
</blockquote>

<p>Really, this has happened to me several times. Luckily so far the "requests" have been for features I was already working on, so I've managed to satisfy these without having to bow to any whims. Strangely they do get all gushy afterwards.</p>

<h4>The Affronted</h4>

<p>Affronted that after skipping the description and reading just the name and maybe glancing at the icon of the app, it turns out not to do what they wanted - the confusion thus engendered renders the app's very existence <em>a personal insult</em>.</p>

<blockquote>
  <p>&#9733;&#9734;&#9734;&#9734;&#9734; <em>D. Idnot RTFM</em> on April 16th, 2012 (Samsung Universe XVI with version 2.0.1)</p>
  
  <p>"I ecspected this app to XXX but it dusnt it only YYY sooooo ridicolus OMFG I waisted nerly 30 seconds of my life on this thing and then I culdnt make it XXX but it shoud and like whatever this sux, dont waist ur life on this"</p>
</blockquote>

<p>OK, nothing much I an do about that, except try to come up with a better name / more descriptive icon / shorter and more pointed description. I guess I just have to hope that other potential downloaders do read the app description and take these kinds of comments with a pinch of salt. </p>

<h4>The Cryptic Critic</h4>

<blockquote>
  <p>&#9733;&#9734;&#9734;&#9734;&#9734; on April 16th, 2012 (HTC Wonderful with version 2.0.1)</p>
  
  <p>"Shocking. So baaad. Even the icons suck. WTF!?"</p>
</blockquote>

<p>OK, come on guys! Shocking how? What's bad? Why do the icons suck? Give us a frigging clue here! There must have been something about the app that tempted you to download (unless I've mislabelled one of The Affronted), so presumably the issues with the app could have been worked out.</p>

<p>Except Google didn't give me the chance to help you, or to improve the app for those that come after, because I have <em>no way</em> to answer the comment, publicly or privately, or to try to get any further information from the complainant.</p>

<h2>Options for Developers on Google Play</h2>

<h3>Build great apps</h3>

<p>OK, this one sounds obvious, but its hard to build a great app on the first shot without any helpful feedback. </p>

<p>As a solo developer its especially hard, actually, to see your own mistakes and evaluate the quality of something when you are so close to the work. If you have a company or a team working on an app there are lots of eyes and minds to spot mistakes, find bugs, and think of improvements.</p>

<p>There are a few things we could do as developers, but I'm not sure of the efficacy of these strategies: </p>

<ul>
<li>Build diagnostics into our own apps - crash reports are very very useful, but miss a lot of vital information (Android version!? Heap size on <em>all</em> memory errors!?). We either have to wait for Google to make improvements or DIY it.</li>
<li>Build feedback into our own apps - ask the user to submit feedback from within the app, and record and publish that feedback on the developers website. Doesn't solve the problem of comments on the Google market, but <em>might</em> make it possible to engage in a conversation with a percentage of the users you would otherwise be unable to talk to.</li>
<li>Switch allegiance to Amazon's store. Of course, then you have to pay a fee to join, and are subject to an Apple-like review process, and I've no idea if the result is worth it - do Amazon solve any of the problems with Google's market?</li>
<li>Build our own market that does a better job. No seriously, I'd love to do this. Of course, its a massive undertaking, and would require an incredible confluence of circumstances (or marketing budget) to really take off.</li>
</ul>

<h3>Self comment</h3>

<p>On my free app I added a comment of my own, and I periodically freshen it up so it stays near the top of the stack so new commenters see it. Here's what it says:</p>

<blockquote>
  <p>&#9733;&#9733;&#9733;&#9733;&#9733; steve on March 10, 2012 (Samsung Galaxy S2 with version 1.5.4)
  I am the developer...</p>
  
  <p>Hi all! Please consider contacting me before leaving a negative review - I am very keen to improve the app, will fix reported bugs quickly, and will add popularly requested features! </p>
  
  <p>If you only leave a comment like "forces close" I can't fix it because it doesn't give me any info to work with - that makes me sad.</p>
</blockquote>

<p>Yes, I five-starred my own app. I don't feel bad actually, because how else can I contend with Google's broken ratings/comment system?</p>

<p>Unfortunately I'm not allowed to buy my own paid app, so this technique doesn't work there. I have added more or less the same information in the app description but, as we know, not everyone reads the descriptions.</p>

<blockquote>
  <p>Please please, if you have any problems at all contact us directly by email - crash reports and comments are great but Google don't give us any way to contact you back!!</p>
</blockquote>

<p>To be fair, many (paying) users have emailed me, as has one person who wanted the app but couldn't download either free or paid versions on her device (apparent Market bug! I sent her the paid app for free and contacted the device manufacturer - Samsung - as there's no clear way to contact Google).</p>

<p>Sometimes when I've had negative comments from paying users I've been able to contact them by matching up the purchase record with the information in the comment. </p>

<p>I can't always match them up, but when I can they are never surprised that I was able to contact them. They <em>expect</em> that commenting makes their information available to the developer. Why wouldn't it?</p>

<h3>Mark as spam</h3>

<p>The only tool Google give developers to deal with comments is a spam/not-spam toggle. I don't think its appropriate to mark genuine comments (and I do think all of the above are genuine comments) as spam.</p>

<p>I understand this tool was added some time ago because there were big spam problems. So far I didn't get any spam comments at all.</p>

<h3>Paid vs Free</h3>

<p>Strangely, the users of paid apps are typically much more polite and less inclined to negatively review. They are more often inclined to email for help and delighted to get a response. </p>

<p>Could be its the <a href="http://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=principle%20of%20commitment&amp;source=web&amp;cd=2&amp;ved=0CDcQFjAB&amp;url=http%3A%2F%2Fsumitdhar.blogspot.com%2F2005%2F09%2Finfluence-techniques-commitment.html&amp;ei=AhNET9KDG9OJhQfjl8XnBQ&amp;usg=AFQjCNE8lIgMAPaBaWA2A1-D09qravE6Ew">Principle of Commitment</a> and maybe <a href="http://en.wikipedia.org/wiki/Post-purchase_rationalization">Post-purchase Rationalisation</a> at work? Or maybe its just the demographic of free vs paid users?</p>

<p>I'm strongly considering never publishing a free app again, just for the reduced hassle.</p>

<h2>What Google can do to help developers</h2>

<p>I don't pretend to have all the answers, but a few small things would make my life as an Android developer much easier:</p>

<ul>
<li>Give developers access to the email address of commenters, or even a way to contact them via Google that keeps them anonymous. I imagine Google think that they are protecting users by anonymising them, but its really not helping anyone.</li>
<li>Allow threaded comments. That would be enough - if I could respond, and the commenter was alerted to the response, an awful lot of problems and misunderstandings could be cleared up quickly. This would be massively to Google's benefit, reducing user and developer frustration!</li>
<li>Include more device info in crash reports and comments (e.g. Android build versions and heap size for starters)</li>
<li>Maintain a list of device specs or emulator configurations that can be used to replicate crashes or bugs reported by users - including things like the damn heap size. I can't afford to buy one of every device on the market - my developer console states "This application is available to over 1245 devices.".</li>
</ul>

<p>Please Google, please just help us to help our users. Help us to make the Android eco-system better. Help us to generate more profits for you. Everyone wins.</p>

<p><em>p.s. I found a <a href="http://productforums.google.com/forum/#!category-topic/android-market/feature-requests--suggestions/Ks4Eyg-UnpA">product-forums thread</a> on this topic where the originating comment dates back to May 2009 and raises many of the same points I've raised here. Clearly Google's priorities lie elsewhere :(</em></p>
</span>

              <ul class="keywords">
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=Android Market">Android Market</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=Google Play">Google Play</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=Comments">Comments</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=Fail">Fail</a></li>
              </ul>
              <div style="clear:both"></div>

	        <a href="android_market_comments_severe_fail.html">Comment on this post</a>

            </div>
	    <div class="article" itemscope itemtype="http://schema.org/BlogPosting" inLanguage="en-GB" isFamilyFriendly="true" wordCount="6,838" description="Example code and performance comparisons for parsing Twitter Atom feeds with various Java XML parsing tools.">
              <span class="meta" itemprop="datePublished"><time datetime="2012-04-10">April 10, 2012</time></span>
              <a itemprop="url" href="comparing_methods_of_xml_parsing_in_android.html"><h1 itemprop="name" itemprop="headline">Comparing methods of XML parsing in Android</h1></a>
	      <span itemprop="articleBody"><p>This post details my experiments parsing the same document with the usual-suspects - DOM, SAX, and Pull parsing - and comparing the results for readability and performance - especially for Android. The parsing mechanisms compared here are:</p>

<ol>
<li>W3C DOM parsing</li>
<li>W3C DOM and XPath</li>
<li>SAX Parsing</li>
<li>Pull Parsing</li>
<li><a href="https://github.com/steveliles/dsl4xml">dsl4xml</a> (dsl around Pull-parser)</li>
<li><a href="http://www.thebuzzmedia.com/software/simple-java-xml-parser-sjxp/">SJXP</a> (thin Pull-parser wrapper using xpath-like expressions)</li>
</ol>

<p>I hope to add more later - some contenders include: <a href="http://www.oracle.com/technetwork/articles/javase/index-140168.html">jaxb</a>; <a href="http://xstream.codehaus.org/">xstream</a>; and <a href="http://simple.sourceforge.net/">Simple</a>.</p>

<p>The <a href="https://github.com/steveliles/dsl4xml-perf">code for the entire project</a> is in github. You will need to Maven install the <a href="https://github.com/steveliles/dsl4xml">dsl4xml</a> library if you want to run the tests yourself, as I'm afraid I don't have a public repo for it yet.</p>

<p><em>Important Note</em>: This experiment was inspired by some work I did to optimise a slow Android app, where the original authors had used mostly DOM parsing with a sprinkling of XPath. </p>

<p>My ultimate aim was to run these perf tests on one or more real Android devices and show how they compare there.</p>

<p>For this reason if you look at the project in github, you'll see that I've imported the Android 4 jar and used only the parser implementations that are available without additional imports in Android. (OK, the two pull-parser wrappers require very small standalone jars, sorry).</p>

<p>The Android project and Activity for running the tests on a device is in a separate project <a href="https://github.com/steveliles/dsl4xml-perf-android">here</a>.</p>

<h2>The XML</h2>

<p>The XML file being parsed is a Twitter search result (Atom feed). You can see the actual file <a href="https://github.com/steveliles/dsl4xml-perf/blob/master/src/main/java/com/sjl/dsl4xml/performance/model/twitter-atom.xml">here</a>, but this is a snippet of the parts I'm interested in parsing for these tests (the 15 <code>&lt;entry&gt;</code>'s in the document):</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;feed .. &gt;
  ..
  &lt;entry&gt;
    ..
    &lt;published&gt;2012-04-09T10:10:24Z&lt;/published&gt;
    &lt;title&gt;Tweet title&lt;/title&gt;
    &lt;content type="html"&gt;Full tweet content&lt;/content&gt;
    ..
    &lt;twitter:lang&gt;en&lt;/twitter:lang&gt;
    &lt;author&gt;
        &lt;name&gt;steveliles (Steve Liles)&lt;/name&gt;
        &lt;uri&gt;http://twitter.com/steveliles&lt;/uri&gt;
    &lt;/author&gt;
  &lt;/entry&gt;
  ..
&lt;/feed&gt;
</code></pre>

<h2>The POJO's</h2>

<p>The Java objects we're unmarshalling to are very simple and don't need any explanation. You can see them in Github <a href="https://github.com/steveliles/dsl4xml-perf/tree/master/src/main/java/com/sjl/dsl4xml/performance/model">here</a>.</p>

<h2>Parsing the Twitter/Atom feed</h2>

<p>First, just a few notes on what I'm trying to do. I basically want to compare two things:</p>

<ol>
<li>Readability/maintainability of <em>typical</em> parsing code.</li>
<li>Parsing performance with said <em>typical</em> parsing code, incl. under concurrent load.</li>
</ol>

<p>With that in mind, I've tried to keep the parsing code small, tight, and (AFAIK) typical for each mechanism, but without layering any further libraries or helper methods on top. </p>

<p>In working with each parsing mechanism I have tried to choose more performant approaches where the readability trade-off is not high.</p>

<p>Without further ado, lets see what parsing this document and marshalling to Java objects is like using the various libraries.</p>

<h3>W3C DOM</h3>

<p>DOM (Document Object Model) parsing builds an in-memory object representation of the entire XML document. You can then rummage around in the DOM, going and back and forth between elements and reading data from them in whatever order you like.</p>

<p>Because the entire document is read into memory, there is an upper limit on the size of document you can read (constrained by the size of your Java heap). </p>

<p>Memory is not used particularly efficiently either - a DOM may consist of very many sparsely populated <code>List</code> objects (backed by mostly empty arrays). A side effect of all these objects in memory is that when you're finished with them there's a lot for the Garbage Collector to clean up.</p>

<p>On the plus side, DOM parsing is straight-forward to work with, particularly if you don't care much about speed and use <code>getElementsByTagName()</code> wherever possible.</p>

<p>The actual code I used for the performance test is <a href="https://github.com/steveliles/dsl4xml-perf/blob/master/src/main/java/com/sjl/dsl4xml/performance/parsers/DOMTweetsReader.java">here</a>, but this is roughly what it ended up looking like:</p>

<pre><code>private DocumentBuilder builder;
private DateFormat dateFormat;

public DOMTweetsReader() 
throws Exception {
    DocumentBuilderFactory factory = 
        DocumentBuilderFactory.newInstance();
    builder = factory.newDocumentBuilder();
    dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
}

@Override
public String getParserName() {
    return "W3C DOM";
}

public Tweets read(InputStream anInputStream) 
throws Exception {
    Document _d = builder.parse(anInputStream, "utf-8");
    Tweets _result = new Tweets();
    unmarshall(_d, _result);
    return _result;
}

public void unmarshall(Document aDoc, Tweets aTo) 
throws Exception {
    NodeList _nodes = aDoc.getChildNodes().item(0).getChildNodes();
    for (int i=0; i&amp;lt;_nodes.getLength(); i++) {
        Node _n = _nodes.item(i);
        if ((_n.getNodeType() == Node.ELEMENT_NODE) &amp;&amp; 
            ("entry".equals(_n.getNodeName())
         ){
            Tweet _tweet = new Tweet();
            aTo.addTweet(_tweet);
            unmarshallEntry((Element)_n, _tweet);
        }
    }
}

private void unmarshallEntry(Element aTweetEl, Tweet aTo)
throws Exception {
    NodeList _nodes = aTweetEl.getChildNodes();
    for (int i=0; i&amp;lt;_nodes.getLength(); i++) {
        Node _n = _nodes.item(i);
        if (_n.getNodeType() == Node.ELEMENT_NODE) {                    
            if ("published".equals(_n.getNodeName())) {                         
                aTo.setPublished(dateFormat.parse(getPCData(_n)));
            } else if ("title".equals(_n.getNodeName())) {
                aTo.setTitle(getPCData(_n));
            } else if ("content".equals(_n.getNodeName())) {
                Content _content = new Content();
                aTo.setContent(_content);
                unmarshallContent((Element)_n, _content);
            } else if ("lang".equals(_n.getNodeName())) {
                aTo.setLanguage(getPCData(_n));
            } else if ("author".equals(_n.getNodeName())) {
                Author _author = new Author();
                aTo.setAuthor(_author);
                unmarshallAuthor((Element)_n, _author);
            }
        }
    }
}

private void unmarshallContent(Element aContentEl, Content aTo) {
    aTo.setType(aContentEl.getAttribute("type"));
    aTo.setValue(aContentEl.getNodeValue());
}

private void unmarshallAuthor(Element anAuthorEl, Author aTo) {
    NodeList _nodes = anAuthorEl.getChildNodes();
    for (int i=0; i&amp;lt;_nodes.getLength(); i++) {
        Node _n = _nodes.item(i);
        if ("name".equals(_n.getNodeName())) {
            aTo.setName(getPCData(_n));
        } else if ("uri".equals(_n.getNodeName())) {
            aTo.setUri(getPCData(_n));
        }
    }
}

private String getPCData(Node aNode) {
    StringBuilder _sb = new StringBuilder();
    if (Node.ELEMENT_NODE == aNode.getNodeType()) {
        NodeList _nodes = aNode.getChildNodes();
        for (int i=0; i&amp;lt;_nodes.getLength(); i++) {
            Node _n = _nodes.item(i);
            if (Node.ELEMENT_NODE == _n.getNodeType()) {
                _sb.append(getPCData(_n));
            } else if (Node.TEXT_NODE == _n.getNodeType()) {
                _sb.append(_n.getNodeValue());
            }
        }
    }
    return _sb.toString();
}
</code></pre>

<p>Its worth noting that I would normally extract some useful utility classes/methods - for example <code>getPCData(Node)</code> - but here I'm trying to keep the sample self-contained.</p>

<p>Note that this code is not thread-safe because of the unsynchronized use of <code>SimpleDateFormat</code>. I am using separate instances of the Reader classes in each thread for my threaded tests.</p>

<h3>W3C DOM and XPath</h3>

<p>XPath is a language for describing locations within an XML document as paths from a starting location (which can be the root of the document (/), the current location (.//) or anywhere (//)).</p>

<p>I've used XPath on and off for years, mostly in XSLT stylesheets, but also occasionally to pluck bits of information out of documents in code. It is very straight-forward to use.</p>

<p>Here's a sample for parsing our Twitter Atom feed. The <a href="https://github.com/steveliles/dsl4xml-perf/blob/master/src/main/java/com/sjl/dsl4xml/performance/parsers/DOMXPathTweetsReader.java">actual test code</a> is in github.</p>

<pre><code>private DocumentBuilder builder;
private XPathFactory factory;

private XPathExpression entry;
private XPathExpression published;
private XPathExpression title;
private XPathExpression contentType;
private XPathExpression content;
private XPathExpression lang;
private XPathExpression authorName;
private XPathExpression authorUri;

private DateFormat dateFormat;

public DOMXPathTweetsReader() 
throws Exception {
    DocumentBuilderFactory _dbf = 
        DocumentBuilderFactory.newInstance();
    _dbf.setNamespaceAware(true);
    builder = _dbf.newDocumentBuilder();
    factory = XPathFactory.newInstance();

    NamespaceContext _ctx = new NamespaceContext() {
        public String getNamespaceURI(String aPrefix) {
            String _uri;
            if (aPrefix.equals("atom"))
                _uri = "http://www.w3.org/2005/Atom";
            else if (aPrefix.equals("twitter"))
                _uri = "http://api.twitter.com/";
            else
                _uri = null;
            return _uri;
        }

        @Override
        public String getPrefix(String aArg0) {
            return null;
        }

        @Override
        @SuppressWarnings("rawtypes")
        public Iterator getPrefixes(String aArg0) {
            return null;
        }
    };

    entry = newXPath(factory, _ctx, "/atom:feed/atom:entry");
    published = newXPath(factory, _ctx, ".//atom:published");
    title = newXPath(factory, _ctx, ".//atom:title");
    contentType = newXPath(factory, _ctx, ".//atom:content/@type");
    content = newXPath(factory, _ctx, ".//atom:content");
    lang = newXPath(factory, _ctx, ".//twitter:lang");
    authorName = newXPath(factory, _ctx, ".//atom:author/atom:name");
    authorUri = newXPath(factory, _ctx, ".//atom:author/atom:uri");

    dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
}

private XPathExpression newXPath(
    XPathFactory aFactory, NamespaceContext aCtx, String anXPath
) throws Exception {
    XPath _xp = factory.newXPath();
    _xp.setNamespaceContext(aCtx);
    return _xp.compile(anXPath);
}

@Override
public String getParserName() {
    return "W3C DOM/XPath";
}

@Override
public Tweets read(InputStream anInputStream)
throws Exception {
    Tweets _result = new Tweets();
    Document _document = builder.parse(anInputStream);

    NodeList _entries = (NodeList) 
        entry.evaluate(_document, XPathConstants.NODESET);                  
    for (int i=0; i&amp;lt;_entries.getLength(); i++) {
        Tweet _tweet = new Tweet();
        _result.addTweet(_tweet);

        Node _entryNode = _entries.item(i);

        _tweet.setPublished(getPublishedDate(_entryNode));
        _tweet.setTitle(title.evaluate(_entryNode));
        _tweet.setLanguage(lang.evaluate(_entryNode));

        Content _c = new Content();
        _tweet.setContent(_c);

        _c.setType(contentType.evaluate(_entryNode));
        _c.setValue(content.evaluate(_entryNode));

        Author _a = new Author();
        _tweet.setAuthor(_a);

        _a.setName(authorName.evaluate(_entryNode));
        _a.setUri(authorUri.evaluate(_entryNode));
    }

    return _result;
}

private Date getPublishedDate(Node aNode) 
throws Exception {
    return dateFormat.parse(published.evaluate(aNode));
}
</code></pre>

<p>The code ends up being quite easy to read and can be written to nest in a way that mimics the document structure. There is a very big downside - as you'll see later - the performance is <em>atrocious</em>. </p>

<h3>SAX Parser</h3>

<p>SAX stands for Simple API for XML. It uses a "push" approach: whereas with DOM you can dig around in the document in whatever order you like, SAX parsing is event-driven which means you have to handle the data as it is given to you.</p>

<p>SAX parsers fire events when they encounter the various components that make up an XML file. You register a <code>ContentHandler</code> whose methods are called-back when these events occur (for example when the parser finds a new start element, it invokes the startElement method of your <code>ContentHandler</code>).</p>

<p>The API assumes that the consumer (<code>ContentHandler</code>) is going to maintain some awareness of its state (e.g. where it currently is within the document). I sometimes use a <code>java.util.Stack</code> to push/pop/peek at which element I'm currently working in, but here I can get away with just recording the name of the current element.</p>

<p>I'm extending <code>DefaultHandler</code> because I'm not interested in many of the events (it provides a default empty implementation of those methods for me).</p>

<p>The <a href="https://github.com/steveliles/dsl4xml-perf/blob/master/src/main/java/com/sjl/dsl4xml/performance/parsers/SAXTweetsReader.java">actual test code</a> is in github, and is actually more complex in order to handle entity-refs via a <code>LexicalHandler</code>,  but here's the gist of it:</p>

<pre><code>private XMLReader reader;
private TweetsHandler handler;

public SAXTweetsReader() 
throws Exception {
    SAXParserFactory _f = SAXParserFactory.newInstance();
    SAXParser _p = _f.newSAXParser();
    reader = _p.getXMLReader();
    handler = new TweetsHandler();
    reader.setContentHandler(handler);
}

@Override
public String getParserName() {
    return "SAX";
}

@Override
public Tweets read(InputStream anInputStream) 
throws Exception {
    reader.parse(new InputSource(anInputStream));
    return handler.getResult();
}

private static class TweetsHandler extends DefaultHandler {

    private DateFormat dateFormat = 
        new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
    private Tweets tweets;
    private Tweet tweet;
    private Content content;
    private Author author;
    private String currentElement;

    public Tweets getResult() {
        return tweets;
    }

    @Override
    public void startDocument() throws SAXException {
        tweets = new Tweets();
    }

    @Override
    public void startElement(
        String aUri, String aLocalName, 
        String aQName, Attributes aAttributes
    ) throws SAXException {
        currentElement = aQName;
        if ("entry".equals(aQName)) {
            tweets.addTweet(tweet = new Tweet());
        } else if ("content".equals(aQName)) {
            tweet.setContent(content = new Content());
            content.setType(aAttributes.getValue("type"));
        } else if ("author".equals(aQName)) {
            tweet.setAuthor(author = new Author());
        }
    }

    @Override
    public void endElement(
        String aUri, String aLocalName, String aQName
    ) throws SAXException {
        currentElement = null;
    }

    @Override
    public void characters(char[] aCh, int aStart, int aLength)
    throws SAXException {
        if ("published".equals(currentElement)) {
            try {
                tweet.setPublished(dateFormat.parse(
                    new String(aCh, aStart, aLength))
                );
            } catch (ParseException anExc) {
                throw new SAXException(anExc);
            }
        } else if (
            ("title".equals(currentElement)) &amp;&amp;
            (tweet != null)
        ) {
            tweet.setTitle(new String(aCh, aStart, aLength));
        } else if ("content".equals(currentElement)) {
            content.setValue(new String(aCh, aStart, aLength));
        } else if ("lang".equals(currentElement)) {
            tweet.setLanguage(new String(aCh, aStart, aLength));
        } else if ("name".equals(currentElement)) {
            author.setName(new String(aCh, aStart, aLength));
        } else if ("uri".equals(currentElement)) {
            author.setUri(new String(aCh, aStart, aLength));
        }
    }
}
</code></pre>

<p>One downside when handling more complicated documents is that the <code>ContentHandler</code> can get littered with intermediate state objects - for example here I have the <code>tweet</code>, <code>content</code>, and <code>author</code> fields.</p>

<p>Another is that SAX is very low level and you have to handle pretty much everything - including that text nodes are passed to you in pieces when there are entity-references present.</p>

<h3>Pull Parser</h3>

<p>Pull-parsing is the "pull" to SAX parsing's "push". SAX pushes content at you by firing events as it encounters constructs within the xml document. Pull-parsing lets you ask for (pull) the next significant construct you are interested in.</p>

<p>You still have to take the data in the order it appears in the document - you can't go back and forth through the document like you can with DOM - but you can skip over bits you aren't interested in.</p>

<p><a href="https://github.com/steveliles/dsl4xml-perf/blob/master/src/main/java/com/sjl/dsl4xml/performance/parsers/PullParserTweetsReader.java">Test code</a> is in github, this is roughly what it looks like:</p>

<pre><code>private DateFormat dateFormat;
private XmlPullParserFactory f;
private Tweets tweets;
private Tweet currentTweet;
private Author currentAuthor;

public PullParserTweetsReader() 
throws Exception {
    dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
    f = XmlPullParserFactory.newInstance();
    f.setNamespaceAware(true);
}

@Override
public String getParserName() {
    return "Pull-Parser";
}

@Override
public Tweets read(InputStream anInputStream) throws Exception {
    XmlPullParser _p = f.newPullParser();
    _p.setInput(anInputStream, "utf-8");
    return parse(_p);
}

private Tweets parse(XmlPullParser aParser) 
throws Exception {
    tweets = new Tweets();

    int _e = aParser.next();
    while (_e != XmlPullParser.END_DOCUMENT) {
        if (_e == XmlPullParser.START_TAG) {
            startTag(aParser.getPrefix(), aParser.getName(), aParser);
        }
        _e = aParser.next();
    }

    return tweets;
}

private void startTag(String aPrefix, String aName, XmlPullParser aParser)
throws Exception {
    if ("entry".equals(aName)) {
        tweets.addTweet(currentTweet = new Tweet());
    } else if ("published".equals(aName)) {
        aParser.next();
        currentTweet.setPublished(dateFormat.parse(aParser.getText()));
    } else if (("title".equals(aName)) &amp;&amp; (currentTweet != null)) {
        aParser.next();
        currentTweet.setTitle(aParser.getText());
    } else if ("content".equals(aName)) {
        Content _c = new Content();
        _c.setType(aParser.getAttributeValue(null, "type"));
        aParser.next();
        _c.setValue(aParser.getText());
        currentTweet.setContent(_c);
    } else if ("lang".equals(aName)) {
        aParser.next();
        currentTweet.setLanguage(aParser.getText());
    } else if ("author".equals(aName)) {
        currentTweet.setAuthor(currentAuthor = new Author());
    } else if ("name".equals(aName)) {
        aParser.next();
        currentAuthor.setName(aParser.getText());
    } else if ("uri".equals(aName)) {
        aParser.next();
        currentAuthor.setUri(aParser.getText());
    }
}
</code></pre>

<h3>SJXP (Pull-Parser wrapper)</h3>

<p>The first of the pull-parser <em>wrappers</em> under test, I stumbled upon <a href="http://www.thebuzzmedia.com/software/simple-java-xml-parser-sjxp/">this one</a> yesterday. I liked the idea behind it so decided to give it a try. </p>

<p>I'm a big fan of callbacks generally, and having spent quite some time working with XPath in the past the idea of using XPath-like syntax to request callbacks from the pull-parser seems tempting.</p>

<p>There was one problem I couldn't work around which seems like either a gap in my knowledge (and the documentation) or an irritating bug - when declaring the paths you have to use the full namespace uri <em>even on elements in the default namespace</em>. </p>

<p>This means that my path declarations even on this shallow document are enormous and I had to split them onto three lines to fit the width of my blog.</p>

<p><a href="https://github.com/steveliles/dsl4xml-perf/blob/master/src/main/java/com/sjl/dsl4xml/performance/parsers/SJXPTweetsReader.java">Code is in github</a>, this is the gist of it:</p>

<pre><code>private Tweet currentTweet;
private DateFormat dateFormat;
private XMLParser&amp;lt;Tweets&gt; parser; 

private IRule&amp;lt;Tweets&gt; tweet = new DefaultRule&amp;lt;Tweets&gt;(Type.TAG, 
    "/[http://www.w3.org/2005/Atom]feed" +
    "/[http://www.w3.org/2005/Atom]entry"
) {
    public void handleTag(
        XMLParser&amp;lt;Tweets&gt; aParser, boolean aIsStartTag, Tweets aUserObject) {
        if (aIsStartTag)
            aUserObject.addTweet(currentTweet = new Tweet());
    }   
};

private IRule&amp;lt;Tweets&gt; published = new DefaultRule&amp;lt;Tweets&gt;(Type.CHARACTER, 
    "/[http://www.w3.org/2005/Atom]feed" +
    "/[http://www.w3.org/2005/Atom]entry" +
    "/[http://www.w3.org/2005/Atom]published"
) {
    public void handleParsedCharacters(
        XMLParser&amp;lt;Tweets&gt; aParser, String aText, Tweets aUserObject
    ) {
        try {                   
            currentTweet.setPublished(dateFormat.parse(aText));
        } catch (ParseException anExc) {
            throw new XMLParserException("date-parsing problem", anExc);
        }
    }           
}; 

private IRule&amp;lt;Tweets&gt; title = new DefaultRule&amp;lt;Tweets&gt;(Type.CHARACTER, 
    "/[http://www.w3.org/2005/Atom]feed" +
    "/[http://www.w3.org/2005/Atom]entry" +
    "/[http://www.w3.org/2005/Atom]title"
) {
    public void handleParsedCharacters(
        XMLParser&amp;lt;Tweets&gt; aParser, String aText, Tweets aUserObject
    ) {
        currentTweet.setTitle(aText);
    }           
};

IRule&amp;lt;Tweets&gt; content = new DefaultRule&amp;lt;Tweets&gt;(Type.TAG, 
    "/[http://www.w3.org/2005/Atom]feed" +
    "/[http://www.w3.org/2005/Atom]entry" +
    "/[http://www.w3.org/2005/Atom]content" +
) {
    public void handleTag(
        XMLParser&amp;lt;Tweets&gt; aParser, boolean aIsStartTag, Tweets aUserObject
    ) {
        if (aIsStartTag)
            currentTweet.setContent(new Content());
        super.handleTag(aParser, aIsStartTag, aUserObject);
    }
};

private IRule&amp;lt;Tweets&gt; contentType = new DefaultRule&amp;lt;Tweets&gt;(Type.ATTRIBUTE, 
    "/[http://www.w3.org/2005/Atom]feed" +
    "/[http://www.w3.org/2005/Atom]entry" +
    "/[http://www.w3.org/2005/Atom]content", "type"
) {
    public void handleParsedAttribute(
        XMLParser&amp;lt;Tweets&gt; aParser, int aIndex, String aValue, Tweets aUserObject
    ) {                 
        currentTweet.getContent().setType(aValue);
    }
};

private IRule&amp;lt;Tweets&gt; contentText = new DefaultRule&amp;lt;Tweets&gt;(Type.CHARACTER, 
    "/[http://www.w3.org/2005/Atom]feed" +
    "/[http://www.w3.org/2005/Atom]entry" +
    "/[http://www.w3.org/2005/Atom]content"
) {
    public void handleParsedCharacters(
        XMLParser&amp;lt;Tweets&gt; aParser, String aText, Tweets aUserObject
    ) {                 
        currentTweet.getContent().setValue(aText);
    }
};

private IRule&amp;lt;Tweets&gt; lang = new DefaultRule&amp;lt;Tweets&gt;(Type.CHARACTER, 
    "/[http://www.w3.org/2005/Atom]feed" +
    "/[http://www.w3.org/2005/Atom]entry" +
    "/[http://api.twitter.com/]lang"
) {
    public void handleParsedCharacters(
        XMLParser&amp;lt;Tweets&gt; aParser, String aText, Tweets aUserObject
    ) {
        currentTweet.setLanguage(aText);
    }
};

private IRule&amp;lt;Tweets&gt; author = new DefaultRule&amp;lt;Tweets&gt;(Type.TAG, 
    "/[http://www.w3.org/2005/Atom]feed" +
    "/[http://www.w3.org/2005/Atom]entry" +
    "/[http://www.w3.org/2005/Atom]author"
) {
    public void handleTag(
        XMLParser&amp;lt;Tweets&gt; aParser, boolean aIsStartTag, Tweets aUserObject
    ) {
        if (aIsStartTag)
            currentTweet.setAuthor(new Author());
        super.handleTag(aParser, aIsStartTag, aUserObject);
    }
};

private IRule&amp;lt;Tweets&gt; authorName = new DefaultRule&amp;lt;Tweets&gt;(Type.CHARACTER, 
    "/[http://www.w3.org/2005/Atom]feed"
    "/[http://www.w3.org/2005/Atom]entry" +
    "/[http://www.w3.org/2005/Atom]author" +
    "/[http://www.w3.org/2005/Atom]name"
) {
    public void handleParsedCharacters(
        XMLParser&amp;lt;Tweets&gt; aParser, String aText, Tweets aUserObject
    ) {
        currentTweet.getAuthor().setName(aText);
    }
};

private IRule&amp;lt;Tweets&gt; authorUri = new DefaultRule&amp;lt;Tweets&gt;(Type.CHARACTER, 
    "/[http://www.w3.org/2005/Atom]feed" +
    "/[http://www.w3.org/2005/Atom]entry" +
    "/[http://www.w3.org/2005/Atom]author" +
    "/[http://www.w3.org/2005/Atom]uri"
) {
    public void handleParsedCharacters(
        XMLParser&amp;lt;Tweets&gt; aParser, String aText, Tweets aUserObject
    ) {
        currentTweet.getAuthor().setUri(aText);
    }
};

@SuppressWarnings("all")
public SJXPTweetsReader() {
    dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
    parser = parser = new XMLParser&amp;lt;Tweets&gt;(
        tweet, published, title, content, contentType, 
        contentText, lang, author, authorName, authorUri
    );
}

@Override
public String getParserName() {
    return "SJXP (pull)";
}

@Override
public Tweets read(InputStream anInputStream) 
throws Exception {
    Tweets _result = new Tweets();  
    parser.parse(anInputStream, "utf-8", _result);
    return _result;
}
</code></pre>

<p>I like the idea of SXJP and I think that - particularly on more complex documents - it will lead to code that is easier to understand and maintain because you can consider each part entirely separately. It bulks up with boiler-plate though, especially with that namespace issue I mentioned.</p>

<p>Like SAX and "straight" Pull parsing it also suffers the problem of having to manage intermediate state (in my sample its <code>currentTweet</code>). It does allow a state/context object to be pushed into the callback methods, so I could have passed a customised context class to manage my state in instead of passing <code>Tweets</code>.</p>

<h3>dsl4xml (Pull-parser wrapper)</h3>

<p>This is my own small wrapper around XMLPullParser. The goals and reasons for it are stated at length <a href="https://github.com/steveliles/dsl4xml">else</a>-<a href="http://steveliles.github.com/xml_parsing_in_android.html">where</a>, but suffice to say that readability without sacrificing speed was my main aim.</p>

<p>Dsl4xml parsing code has a declarative style, is concise, and uses reflection to cut boiler-plate to a minimum.</p>

<p><a href="https://github.com/steveliles/dsl4xml-perf/blob/master/src/main/java/com/sjl/dsl4xml/performance/parsers/Dsl4XmlPullTweetsReader.java">Actual code</a> is in Github, here's what it looks like:</p>

<pre><code>private DocumentReader&amp;lt;Tweets&gt; reader;

public Dsl4XmlTweetsReader() {
    reader = mappingOf(Tweets.class).to(
        tag("entry", Tweet.class).with(
            tag("published"),
            tag("title"),
            tag("content", Content.class).with(
                attribute("type"),
                pcdataMappedTo("value")
            ),
            tag("twitter", "lang").
                withPCDataMappedTo("language"),
            tag("author", Author.class).with(
                tag("name"),
                tag("uri")
            )
        )
    );

    reader.registerConverters(
        new ThreadUnsafeDateConverter("yyyy-MM-dd'T'HH:mm:ss")
    );
}

@Override
public String getParserName() {
    return "DSL4XML (pull)";
}

@Override
public Tweets read(InputStream anInputStream) throws Exception {
    return reader.read(anInputStream, "utf-8");
}
</code></pre>

<p>There are two things I want to point out, which I guess you will have noticed already:</p>

<ol>
<li>This is by far the shortest and simplest code of all the samples shown.</li>
<li>The code is slightly unusual in its style because it uses an <a href="http://martinfowler.com/bliki/DomainSpecificLanguage.html">Internal Domain Specific Language</a>. The nice thing (IMHO) is that it is very readable, and even mimics the structure of the XML itself.</li>
</ol>

<p>Its still early days for dsl4xml, so the DSL may evolve a bit with time. I'm also looking into ways to keep the same tight syntax without resorting to reflection - the aim being to narrow the performance gap between the raw underlying parser (currently a Pull parser) and dsl4xml.</p>

<h2>Performance Comparison</h2>

<p>I built some performance tests using the mechanisms described above to parse the same document repeatedly. </p>

<p>The tests are run repeatedly with increasing numbers of threads, from 1 to 8, parsing 1000 documents in each thread. The xml document is read into a byte array in memory before the test starts to eliminate disk IO from consideration.</p>

<p>When the statistics for each method have been collected, the test generates a html document that uses Google charts to render the results.</p>

<p>Each parsing method is tested several times and the results averaged to smooth out some of the wilder outliers (still far from perfect, partly due to garbage collection). I ran the tests on my Linux Desktop, Macbook Air, Samsung Galaxy S2 and Morotola Xoom2 Media Edition. </p>

<p>Here is the chart for the desktop (Core i7 (quad) 1.8GHz, 4GB RAM, Ubuntu 11.10, Sun JDK 1.6.0-26). There is a noticeable hump at 4 threads, presumably because its a quad core. Performance keeps rising up to 8 threads, this presumably because the cpu has hyperthreading. After 8 threads the performance slowly drops off as the context-switching overhead builds up (not shown here):</p>

<div id="desktop_chart_div"></div>

<p>And here's the chart from my MacBook Air (Core i5 (dual) 1.7GHz, 4GB RAM, OSX Lion, Apple JDK 1.6.0-31):</p>

<div id="laptop_chart_div"></div>

<p>The difference running under Android is, to put it mildly, astonishing. Here's the chart from my Samsung Galaxy S2 running Android 2.3.4, 64Mb heap. I reduced the max concurrency to 4 and the number of documents parsed per thread to 10, otherwise my phone would be obsolete before the results came back :)</p>

<div id="mobile_chart_div"></div>

<p>Yep, SAX kicking ass right there.</p>

<p>Here's how it looks on a Motorola Xoom 2 Media edition running Android 3.2.2 (with 48Mb heap):</p>

<div id="tablet_chart_div"></div>

<p>Confirming that SAX is the way to go on Android!</p>

<h4>Quick side note about iOS</h4>

<p>My friend <a href="http://twitter.com/#!/prestonmr">Matt Preston</a> did a quick port of the <em>DOM</em> and <em>SAX</em> parsing tests to iOS. </p>

<p>He didn't produce a chart (yet!), but the <em>DOM</em> parsing throughput on an iPhone 4S was approximately twice as good as <em>SAX</em> parsing on my Samsung. SAX Parsing on the iPhone churned through on average 150 docs/sec!</p>

<p>Its interesting to note that the iPhone4S runs a 1GHz Cortex A9 CPU <em>clocked down</em> to 800Mhz, while my Samsung is running a <em>1.2GHz</em> Cortex A9.</p>

<h4>Why XPath parsing sucked so bad</h4>

<p>The observant will have noticed the charts do not contain figures for the XPath parsing. That's because I dropped it when I realised it was two orders of magnitude slower even than DOM parsing.</p>

<p>This appalling performance seems to be because when executing <em>each</em> xpath expression a context object is created which involves looking up several files on the classpath (and all the inherent synchronisation this entails). I don't intend to waste my time digging into why this can't done once and cached :(.</p>

<p>If you're interested, this is what my threads spent most of their time doing in the XPath test:</p>

<pre><code>"Thread-11" prio=5 tid=7fcf544d2000 nid=0x10d6bb000 
    waiting for monitor entry [10d6b9000]
    java.lang.Thread.State: BLOCKED (on object monitor)
    at java.util.zip.ZipFile.getEntry(ZipFile.java:159)
    - locked &amp;lt;7f4514c88&gt; (a java.util.jar.JarFile)
    at java.util.jar.JarFile.getEntry(JarFile.java:208)
    at java.util.jar.JarFile.getJarEntry(JarFile.java:191)
    at sun.misc.URLClassPath$JarLoader.getResource(URLClassPath.java:757)
    at sun.misc.URLClassPath$JarLoader.findResource(URLClassPath.java:735)
    at sun.misc.URLClassPath.findResource(URLClassPath.java:146)
    at java.net.URLClassLoader$2.run(URLClassLoader.java:385)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findResource(URLClassLoader.java:382)
    at java.lang.ClassLoader.getResource(ClassLoader.java:1002)
    at java.lang.ClassLoader.getResource(ClassLoader.java:997)
    at java.lang.ClassLoader.getSystemResource(ClassLoader.java:1100)
    at java.lang.ClassLoader.getSystemResourceAsStream(ClassLoader.java:1214)
    at com.sun.org.apache.xml.internal.dtm.SecuritySupport12$6.run
        (SecuritySupport12.java:117)
    at java.security.AccessController.doPrivileged(Native Method)
    at
    com.sun.org.apache.xml.internal.dtm.SecuritySupport12.
        getResourceAsStream(SecuritySupport12.java:112)
    at com.sun.org.apache.xml.internal.dtm.ObjectFactory.
        findJarServiceProviderName(ObjectFactory.java:549)
    at com.sun.org.apache.xml.internal.dtm.ObjectFactory.
        lookUpFactoryClassName(ObjectFactory.java:373)
    at com.sun.org.apache.xml.internal.dtm.ObjectFactory.
        lookUpFactoryClass(ObjectFactory.java:206)
    at com.sun.org.apache.xml.internal.dtm.ObjectFactory.
        createObject(ObjectFactory.java:131)
    at com.sun.org.apache.xml.internal.dtm.ObjectFactory.
        createObject(ObjectFactory.java:101)
    at com.sun.org.apache.xml.internal.dtm.DTMManager.
        newInstance(DTMManager.java:135)
    at com.sun.org.apache.xpath.internal.XPathContext.
        &amp;lt;init&gt;(XPathContext.java:100)
    at com.sun.org.apache.xpath.internal.jaxp.XPathExpressionImpl.
        eval(XPathExpressionImpl.java:110)
</code></pre>

<h2>Conclusions</h2>

<h3>Readability</h3>

<p>Of the mechanisms tested so far, and from the code samples above, I think that dsl4xml produces far the most readable and maintainable parsing code. Of course I am biased. </p>

<p>I think SAX parsing would have worked out to be the most readable of the other mechanisms if it hadn't been for those pesky entity-refs. As it is I have to recommend Pull-parsing as the way to go for readability.</p>

<h3>Desktop/laptop xml parsing performance</h3>

<p>SAX parsing and the pull-parsing wrappers give comparable performance. Raw Pull-parsing beats the lot by a margin of around 15%. DOM performs relatively badly - around twice as slow as any of the others. Don't go near XPath based parsing unless you like watching paint dry.</p>

<p>Recommendation: Pull Parser for max performance and relative ease of use. Dsl4xml if you want performance <em>and</em> great readability :)</p>

<h3>Android xml parsing performance</h3>

<p>Avoid XPath at all costs. DOM and pull-parsing appear to have similarly poor performance characteristics. SAX absolutely <em>destroys</em> all the others - roughly an order of magnitude quicker.</p>

<p>Recommendation: SAX, every time. I'll get working on a SAX-based dsl4xml implementation :)</p>

<p><em>Update (23rd April 2012): Just finished a SAX-based dsl4xml - here's the performance chart for my Samsung Galaxy SII again (also includes figures for SimpleXML):</em></p>

<div id="update_chart_div"></div>

<h3>Final words</h3>

<p>The Twitter Atom feed is not particularly complicated - tags are not deeply nested, not too many attributes, no nested tags of the same name, no mixed content (tags and text-nodes as siblings), etc. </p>

<p>I suspect that the performance gap between the different mechanisms widens as the document complexity increases, but as yet have no real evidence to back that up.</p>

<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<script type="text/javascript">
      google.load("visualization", "1", {packages:["corechart"]});
      google.setOnLoadCallback(drawCharts);

      function drawCharts() {
        drawDesktopChart();
        drawLaptopChart();
        drawMobileChart();
        drawTabletChart();
        drawUpdateChart();
      }

      function drawDesktopChart() {
        var data = new google.visualization.DataTable();
        data.addColumn('string', 'Concurrency (threads)');

data.addColumn('number', 'W3C DOM');
data.addColumn('number', 'SAX');
data.addColumn('number', 'Pull');
data.addColumn('number', 'dsl4xml');
data.addColumn('number', 'SJXP');

        data.addRows([

['1', 1832.602735709364, 3047.309539315194, 3173.0422460858813, 3107.05642523978, 3135.5741046887833],
['2', 3582.1149494513074, 5472.478667789554, 7353.287244493242, 5612.2292748296813, 5523.7554631906182],
['3', 4677.6970491022244, 6051.68803044958, 8035.124424148545, 7802.535738870123, 6631.802574047084],
['4', 5359.016501380009, 9074.944239050174, 13088.8170146974735, 10659.357606318107, 9064.701562460433],
['5', 5840.4790247755773, 8386.967417466271, 11803.470921843835, 9494.022503516175, 9404.295333931408],
['6', 7090.0232840469225, 10439.749336350581, 12337.1859987374073, 11472.185791651998, 10465.21753387524],
['7', 7686.6631274700644, 10403.344206920294, 14162.5448904135455, 11761.212554175974, 11103.283101461672],
['8', 7968.051665388115, 10980.660778139436, 14713.042602646617, 12341.624527230158, 12035.611975742948]
        ]);

        var options = {
          title: 'Parsing Throughput (higher is better)',
          hAxis: { title: 'Concurrency (threads)' },
          vAxis: { title: 'Throughput (docs/sec)' }
        };

        var chart = new google.visualization.ColumnChart(document.getElementById('desktop_chart_div'));
        chart.draw(data, options);
      }

    function drawLaptopChart() {
        var data = new google.visualization.DataTable();
        data.addColumn('string', 'Concurrency (threads)');

data.addColumn('number', 'W3C DOM');
data.addColumn('number', 'SAX');
data.addColumn('number', 'Pull');
data.addColumn('number', 'dsl4xml');
data.addColumn('number', 'SJXP');

        data.addRows([

['1', 1832.602735709364, 2647.309539315194, 3473.0422460858813, 2387.05642523978, 2535.5741046887833],
['2', 2182.1149494513074, 3972.478667789554, 5253.287244493242, 4012.2292748296813, 3823.7554631906182],
['3', 2977.6970491022244, 4951.68803044958, 6035.124424148545, 4802.535738870123, 4631.802574047084],
['4', 3559.016501380009, 5074.944239050174, 6388.8170146974735, 5659.357606318107, 5064.701562460433],
['5', 3440.4790247755773, 5386.967417466271, 6103.470921843835, 5494.022503516175, 5404.295333931408],
['6', 3690.0232840469225, 5439.749336350581, 6137.1859987374073, 5472.185791651998, 5465.21753387524],
['7', 3686.6631274700644, 5403.344206920294, 5462.5448904135455, 5761.212554175974, 5503.283101461672],
['8', 3568.051665388115, 5580.660778139436, 6713.042602646617, 5541.624527230158, 5535.611975742948]
        ]);

        var options = {
          title: 'Parsing Throughput (higher is better)',
          hAxis: { title: 'Concurrency (threads)' },
          vAxis: { title: 'Throughput (docs/sec)' }
        };

        var chart = new google.visualization.ColumnChart(document.getElementById('laptop_chart_div'));
        chart.draw(data, options);
      }

    function drawMobileChart() {
        var data = new google.visualization.DataTable();
        data.addColumn('string', 'Concurrency (threads)');

data.addColumn('number', 'W3C DOM');
data.addColumn('number', 'SAX');
data.addColumn('number', 'Pull');
data.addColumn('number', 'dsl4xml');
data.addColumn('number', 'SJXP');

        data.addRows([

['1', 2.541707357944222, 39.240257662110984, 3.5759414102545857, 3.1541200188086482, 2.5026521752567215],
['2', 4.330846368265108, 61.60437643946365, 6.456946359247942, 5.686983737649393, 4.732176431626203],
['3', 4.351606992043577, 61.514316431090535, 6.307925946534443, 5.685825899522886, 4.586118360054465],
['4', 4.459386705412041, 61.89969059133254, 6.448053162500682, 5.741419718006399, 4.58759932615774]
        ]);

        var options = {
          title: 'Parsing Throughput (higher is better)',
          hAxis: { title: 'Concurrency (threads)' },
          vAxis: { title: 'Throughput (docs/sec)' }
        };

        var chart = new google.visualization.ColumnChart(document.getElementById('mobile_chart_div'));
        chart.draw(data, options);
      }

    function drawTabletChart() {
        var data = new google.visualization.DataTable();
        data.addColumn('string', 'Concurrency (threads)');

data.addColumn('number', 'W3C DOM');
data.addColumn('number', 'SAX');
data.addColumn('number', 'Pull');
data.addColumn('number', 'dsl4xml');
data.addColumn('number', 'SJXP');

        data.addRows([

['1', 2.808355131127302, 41.19998995148725, 5.265999845098719, 4.471127605806691, 3.2549656900511446],
['2', 3.7760722761427994, 56.689099096842824, 9.289035040035463, 7.928630708496687, 5.984694902484068],
['3', 3.7462729340199994, 59.54930941243503, 9.301339793390131, 7.970383487927541, 5.957854290081462],
['4', 3.6944918608450323, 58.9957330285963, 9.50247436158096, 8.08040954423548, 6.088092287251627]
        ]);

        var options = {
          title: 'Parsing Throughput (higher is better)',
          hAxis: { title: 'Concurrency (threads)' },
          vAxis: { title: 'Throughput (docs/sec)' }
        };

        var chart = new google.visualization.ColumnChart(document.getElementById('tablet_chart_div'));
        chart.draw(data, options);
      }

      function drawUpdateChart() {

        var data = new google.visualization.DataTable();
        data.addColumn('string', 'Concurrency (threads)');


data.addColumn('number', 'W3C DOM');
data.addColumn('number', 'SAX');
data.addColumn('number', 'Pull');
data.addColumn('number', 'dsl4xml (pull)');
data.addColumn('number', 'dsl4xml (SAX)');
data.addColumn('number', 'SJXP');
data.addColumn('number', 'SimpleXML');

        data.addRows([

['1',2.3990626431189757,43.064527743674304,3.5096192666862467,3.1076837111373043,29.861563321354247,2.4664573717826044,2.3909004146918598],
['2',3.8097945346845243,69.65230695343173,6.033185779344725,5.719798415469687,54.390135966806106,4.19575915770385,3.927812341410011],
['3',3.6368249512540114,71.39012835438209,5.537694525649179,4.886205168164367,58.04773944850799,3.8392278830888653,3.5690149046875117],
['4',3.6586810559054896,78.02354281756789,5.476464455883683,4.989187889389914,60.89659425282844,4.014151778333453,3.6487355420874175]
        ]);

        var options = {
          title: 'Parsing Throughput (higher is better)',
          hAxis: { title: 'Concurrency (threads)' },
          vAxis: { title: 'Throughput (docs/sec)' }
        };

        var chart = new google.visualization.ColumnChart(document.getElementById('update_chart_div'));
        chart.draw(data, options);

      }
</script>
</span>

              <ul class="keywords">
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=java">java</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=xml">xml</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=parse">parse</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=unmarshall">unmarshall</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=comparison">comparison</a></li>
              </ul>
              <div style="clear:both"></div>

	        <a href="comparing_methods_of_xml_parsing_in_android.html">Comment on this post</a>

            </div>
	    <div class="article" itemscope itemtype="http://schema.org/BlogPosting" inLanguage="en-GB" isFamilyFriendly="true" wordCount="2,266" description="Some things I learned while optimising a slow Android app, and a quick intro to dsl4xml for easy and fast xml parsing in Android.">
              <span class="meta" itemprop="datePublished"><time datetime="2012-04-05">April 05, 2012</time></span>
              <a itemprop="url" href="dsl_for_xml_parsing_in_android.html"><h1 itemprop="name" itemprop="headline">DSL for XML parsing in Android</h1></a>
	      <span itemprop="articleBody"><p>For a readability and performance comparison of different parsing mechanisms available in Android, have a look at my <a href="http://steveliles.github.com/comparing_methods_of_xml_parsing_in_android.html">more recent post</a> that compares parsing a Twitter search result using DOM, SAX, and various Pull parsing methods.</p>

<p><em>The short story:</em> Always use SAX in Android (<a href="https://lh3.googleusercontent.com/-npX8w__TdF8/T4avu-kllZI/AAAAAAAAJBo/rfq8oF43gdw/s800/samsung-galaxy-s2-perf.png">here's why</a>).</p>

<p>SAX and Pull-parsing are fast, but don't lead to the most readable/maintainable code. Instead, how about a super-simple internal DSL for describing the mapping for unmarshalling from XML to POJO's, with pull-parsing performance? Quick example:</p>

<pre><code>&lt;books&gt;
  &lt;book&gt;
    &lt;title&gt;The Hobbit&lt;/title&gt;
    &lt;synopsis&gt;
        A little guy goes on an adventure, 
        finds ring, comes back.
    &lt;/synopsis&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;The Lord of the Rings&lt;/title&gt;
    &lt;synopsis&gt;
        A couple of little guys go on an adventure, 
        lose ring, come back.
    &lt;/synopsis&gt;
  &lt;/book&gt;
&lt;/books&gt;
</code></pre>

<p>Can be unmarshalled to simple POJO's with this:</p>

<pre><code>import static com.sjl.dsl4xml.DocumentReader.*;

class BooksReader {
    private DocumentReader&amp;lt;Books&gt; reader;

    public BooksReader() {
        reader = mappingOf(Books.class).to(
           tag("book", Book.class).with(
               tag("title"),
               tag("synopsis")
           )
        );
    }

    public Books reader(Reader aReader) {
        return reader.read(aReader);
    }
}
</code></pre>

<p><em>The long story:</em></p>

<p>I recently had occasion to work on an Android app that was suffering horrible performance problems on startup (approx 7-12 seconds before displaying content).</p>

<p>A look at the code showed up several possible contenders for the source of the problem:</p>

<ol>
<li>Many concurrent http requests to fetch XML content from web</li>
<li>Parsing the returned XML documents concurrently</li>
<li>Parsing documents using DOM (and some XPath)</li>
</ol>

<p>A quick run through with the excellent profiler built in to DDMS immediately showed lots of time spent in DOM methods, and masses of heap being consumed by sparsely populated <code>java.util.List</code> objects (used to represent the DOM in memory).</p>

<p>Since the app was subsequently discarding the parsed Document object, the large heap consumption was contributing a huge garbage-collection load as a side-effect.</p>

<p>Parsing many documents at once meant that the app suffered a perfect storm of exacerbating issues: Slow DOM traversal with XPath; constant thread context-switching; massive heap consumption; and huge object churn.</p>

<p>The network requests - even over 3G - were comparatively insignificant in the grand scheme.</p>

<h2>Reducing thread context switching</h2>

<p>An obvious and inexpensive thing to try at this point was reducing the concurrency to minimise the overhead of context-switching and hopefully enable the CPU caches to be used to best advantage. </p>

<p>I confess I hoped for a significant improvement from this small change, but the difference, while measurable, was too small to be significant (~5-10%).</p>

<h2>More efficient parsing</h2>

<p>XPath is easy to use, and typically makes it possible to write straight-forward code for marshalling data from an XML document into Java objects. It is, however, horribly slow and a terrible memory hog.</p>

<p>I decided to try an experiment with an alternative parsing method, to see if a worthwhile performance gain could be achieved on one of the smaller documents that could then be applied to others.</p>

<p>I wrote a small test-case confirming the correctness of the existing parsing mechanism and testing the throughput in documents per second, then extracted an interface and created a new implementation that used Pull-Parsing instead of DOM and XPath.</p>

<p>The result was quite pleasing: 5x faster on a simple document. I fully expected the performance gains to be even better on more complex documents, so was quite eager to repeat the process for one of the most complex documents. </p>

<p>However, I had one major concern that put me off: the code for parsing even a simple document was already quite long and had a nasty whiff of conditional-overkill (think: lots of if statements). I wasn't too happy about trading code readability for performance.</p>

<p>I pondered a few alternatives like <a href="http://xstream.codehaus.org/">XStream</a> which I've used a lot for converting from Java to XML but not much the other way around, and <a href="http://simple.sourceforge.net/">SimpleXML</a> which I have used previously and can be nice, but pollutes your model objects with annotations and in some situations can be a real pain to get working.</p>

<h2>An Internal DSL for mapping XML to POJO's</h2>

<p>In the end I decided to spend just a few hours turning the problem over in code to see if I could come up with something more readable for working with the pull-parser directly. </p>

<p>The result, after an afternoon of attempting to parse the most complex XML file the app consumed, was a small Internal DSL (Domain Specific Language) for declaratively describing the mapping between an XML and the Java model classes, and a 15x performance improvement in startup time for the app (7-12 seconds down to ~0.5s).</p>

<p>The DSL I originally came up with required some boiler-plate code to do the final mapping between text nodes / attributes and the model classes being populated. If Java had a neat syntax for closures this would have been much less irritating :)</p>

<p>As it was the boiler plate irked me - too much <em>stuff</em> getting in the way of reading what was really important. I thought about it a bit in my spare time, and had another shot at it. My aims were:</p>

<ol>
<li>To make readable, maintainable, declarative code that unmarshalls XML documents to Java objects.</li>
<li>To make unmarshalling XML documents to Java objects very fast (sax/pull-parsing speeds).</li>
<li>To avoid polluting model classes with metadata about xml parsing (no annotations).</li>
<li>To avoid additional build-time steps or "untouchable" code (code generators, etc).</li>
<li>To produce a very small jar with no large dependencies.</li>
</ol>

<p>The result is starting to take shape in github as <a href="https://github.com/steveliles/dsl4xml">dsl4xml</a>. It removes all of the boiler plate in exchange for a small performance penalty due to use of reflection. I don't have comparative performance figures yet, but will post some when I get time.</p>

<h3>Another example</h3>

<p>XML:</p>

<pre><code>&lt;hobbit&gt;
  &lt;name firstname="Frodo" surname="Baggins"/&gt;
  &lt;dob&gt;11400930&lt;/dob&gt;
  &lt;address&gt;
    &lt;house&gt;
      &lt;name&gt;Bag End&lt;/name&gt;
      &lt;number&gt;&lt;/number&gt;
    &lt;/house&gt;
    &lt;street&gt;Bagshot Row&lt;/street&gt;
    &lt;town&gt;Hobbiton&lt;/town&gt;
    &lt;country&gt;The Shire&lt;/country&gt;
  &lt;/address&gt;
&lt;/hobbit&gt;
</code></pre>

<p>POJO's: <a href="https://github.com/steveliles/dsl4xml/commit/ad2141df218a776ebd68a75072feab16a5221fd5#diff-4">See the source-code of the test-case</a></p>

<p>Unmarshalling code:</p>

<pre><code>private static DocumentReader&amp;lt;Hobbit&gt; newReader() {
    DocumentReader&amp;lt;Hobbit&gt; _marshaller = mappingOf(Hobbit.class).to(
        tag("name", Name.class).with(
            attributes("firstname", "surname")
        ),
        tag("dob"),
        tag("address", Address.class).with(
            tag("house", Address.House.class).with(
                tag("name"),
                tag("number")
            ),
            tag("street"),
            tag("town"),
            tag("country")
        )
    );

    _reader.registerConverters(new ThreadUnsafeDateConverter("yyyyMMdd"));

    return _reader;
}
</code></pre>

<p>A <code>DocumentReader</code>, once constructed, is intended to be re-used repeatedly. The <code>DocumentReader</code> itself is <em>completely thread-safe</em> as unmarshalling does not modify any of its internal state. To ensure thread-safety you must use only thread-safe type converters (see type conversion section below).</p>

<p>A minimum of garbage is generated because we're using a pull parser to skip over parts of the document we don't care about, and the only state maintained along the way (in a single-use context object for thread safety) is the domain objects we're creating.</p>

<h3>Type conversion</h3>

<p>You can create and register your own type converters. They are used only to map the lowest level xml data to your Java objects - attribute values and CData <code>String</code>s. The <code>Converter</code> interface looks like this:</p>

<pre><code>package com.sjl.dsl4xml.support;

public interface Converter&amp;lt;T&gt; {
    public boolean canConvertTo(Class&lt;?&gt; aClass);
    public T convert(String aValue);
}
</code></pre>

<p>An example <code>Converter</code> for converting <code>String</code> values to primitive int's looks like this:</p>

<pre><code>class PrimitiveIntConverter implements Converter&amp;lt;Integer&gt; {
    @Override
    public boolean canConvertTo(Class&amp;lt;?&gt; aClass) {
        return aClass.isAssignableFrom(Integer.TYPE);
    }

    @Override
    public Integer convert(String aValue) {
        return ((aValue == null) || ("".equals(aValue))) ? 
            0 : new Integer(aValue);
    }
}
</code></pre>

<p>Most converters can be thread-safe, but some may require concurrency control for multi-threaded use (example: when converting dates using SimpleDateFormat). </p>

<p>You can use optimised type converters in situations where you <em>know</em> you will not be unmarshalling from multiple threads concurrently. An example is the <code>ThreadUnsafeDateConverter</code> which is used in the example above because it came from a test-case that will only ever run single-threaded. </p>

<pre><code>public class ThreadUnsafeDateConverter implements Converter&amp;lt;Date&gt; {
    private DateFormat dateFormat;

    public ThreadUnsafeDateConverter(String aDateFormatPattern) {
        // SimpleDateFormat is NOT thread-safe
        dateFormat = new SimpleDateFormat(aDateFormatPattern);
    }

    @Override
    public boolean canConvertTo(Class&amp;lt;?&gt; aClass) {
        return aClass.isAssignableFrom(Date.class);
    }

    @Override
    public Date convert(String aValue) {
        try {
            return ((aValue == null) || ("".equals(aValue))) ? 
                null : dateFormat.parse(aValue);
        } catch (ParseException anExc) {
            throw new XmlMarshallingException(anExc);
        }
    }
}
</code></pre>

<p>The alternative <code>ThreadSafeDateConverter</code> looks like this:</p>

<pre><code>class ThreadSafeDateConverter implements Converter&amp;lt;Date&gt; {
    private ThreadLocal&amp;lt;DateFormat&gt; dateFormat;

    public ThreadSafeDateConverter(final String aDateFormatPattern) {
        dateFormat = new ThreadLocal&amp;lt;DateFormat&gt;() {
            protected DateFormat initialValue() {
                return new SimpleDateFormat(aDateFormatPattern);
            }
        };
    }

    @Override
    public boolean canConvertTo(Class&amp;lt;?&gt; aClass) {
        return aClass.isAssignableFrom(Date.class);
    }

    @Override
    public Date convert(String aValue) {
        try {
            return ((aValue == null) || ("".equals(aValue))) ? 
                null : dateFormat.get().parse(aValue);
        } catch (ParseException anExc) {
            throw new XmlMarshallingException(anExc);
        }
    }
}
</code></pre>

<h3>Missing features</h3>

<p>This is still a very new project, and in an experimental stage. There's loads still to do:</p>

<ul>
<li>Experiment with more documents to drive improvements to the DSL</li>
<li>More converters for the obvious types (e.g., BigDecimal, BigInteger, File, URI, etc.)</li>
<li>Support for namespaced documents</li>
<li>Support for CDATA (so far only tested with PCDATA)</li>
<li>Performance comparisons with DOM, SAX and non-DSL'd Pull parsing</li>
<li>Support for explicit (non-reflective) marshalling of properties</li>
<li>Support for SAX parsing instead of Pull-Parsing (see notes below)</li>
<li>Performance tests</li>
<li>Performance optimisations</li>
</ul>

<h3>Notes</h3>

<p>I came across some interesting comments by <a href="https://plus.google.com/105051985738280261832/posts">Diane Hackborn</a> (Android platform developer) in <a href="http://groups.google.com/group/android-developers/browse_thread/thread/3f9c5fc7402ecdf">this thread</a>. </p>

<p>Diane points out that SAX parsing is faster than Pull Parsing (at least on Android). I had been under the impression it was the other way around, hence I went with Pull parsing. </p>

<p>Later perf tests show SAX to be <em>much</em> faster on Android, so I will probably refactor to use SAX.</p>

<p><img src="https://lh3.googleusercontent.com/-npX8w__TdF8/T4avu-kllZI/AAAAAAAAJBo/rfq8oF43gdw/s800/samsung-galaxy-s2-perf.png" alt="android parser performance" /></p>
</span>

              <ul class="keywords">
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=xml">xml</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=unmarshall">unmarshall</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=android">android</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=pull-parsing">pull-parsing</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=dsl">dsl</a></li>
              </ul>
              <div style="clear:both"></div>

	        <a href="dsl_for_xml_parsing_in_android.html">Comment on this post</a>

            </div>
	    <div class="article" itemscope itemtype="http://schema.org/BlogPosting" inLanguage="en-GB" isFamilyFriendly="true" wordCount="1,503" description="The Android platform provides AsyncTask for straight-forward handling of background tasks which can re-integrate with the UI thread easily, but you should understand what happens under the hood and use it with care.">
              <span class="meta" itemprop="datePublished"><time datetime="2012-03-26">March 26, 2012</time></span>
              <a itemprop="url" href="android_s_asynctask.html"><h1 itemprop="name" itemprop="headline">Android's AsyncTask</h1></a>
	      <span itemprop="articleBody"><p>The Android platform allows you to use all of the normal Java concurrency constructs. You should use them if you need to do any long-running operations: you must do these off the main UI thread if you want keep your users happy, and the platform even enforces this by displaying an Application Not Responding dialog if an app does not respond to user-input within 5 seconds.</p>

<p>The kinds of things you will want to do off the UI thread are reading/writing data from databases, network calls fetching data from web-servcies, and any time-consuming computational work.</p>

<p>The platform provides a couple of mechanisms to facilitate communication between background threads and the main application thread: <code>Handler</code>'s and <code>AsyncTask</code>s. In this article I want to concentrate on <code>AsyncTask</code>.</p>

<h3>The basics of AsyncTask</h3>

<p>AsyncTask provides a simple API for doing work in the background and re-integrating the result with the main thread. Here's what it looks like:</p>

<pre><code>new AsyncTask&amp;lt;Param, Progress, Result&gt;() {
    protected void onPreExecute() {
        // perhaps show a dialog 
        // with a progress bar
        // to let your users know
        // something is happening
    }

    protected Result doInBackground(Param... aParams) {
        // do some expensive work 
        // in the background here
    }

    protected void onPostExecute(Result aResult) {
        // background work is finished, 
        // we can update the UI here
        // including removing the dialog
    }
}.execute();
</code></pre>

<p>The template methods <code>onPreExecute()</code> and <code>onPostExecute(Result)</code> are invoked such that you can safely update the UI from there. </p>

<p>There is a fourth template method - <code>onProgressUpdate(Progress[])</code> - which you can implement if you want to update the UI to show progress is being made within the background thread. For this to actually work you will need to invoke <code>publishProgress(Progress[])</code> regularly from within <code>doInBackground(Param[])</code>.</p>

<p>AsyncTask is generic, and presents three type variables:</p>

<pre><code>class AsyncTask&amp;lt;Params, Progress, Result&gt;
</code></pre>

<p>They are used as follows:</p>

<ol>
<li><code>Params</code> is the argument type for the <em>varargs array</em> passed in to doInBackground.</li>
<li><code>Progress</code> is the argument type for the <em>varargs array</em> passed in to <code>onProgressUpdate</code>, and so is also the type (of array) you must use when invoking <code>publishProgress</code>.</li>
<li><code>Result</code> is the return type of <code>doInBackground</code>, which in turn is the argument type passed in to <code>onPostExecute</code>.</li>
</ol>

<h3>What happens when you execute()?</h3>

<p>When <code>execute(Object.. params)</code> is invoked on an <code>AsyncTask</code> the task is executed in a background thread. Depending on the platform <code>AsyncTask</code>s may be executed serially (pre 1.6 and potentially again in 4+), or concurrently (1.6-3.2). </p>

<p>To be sure of running serially or concurrently as you require, from API Level 11 onwards you can use the <code>executeOnExecutor(Executor executor, Object.. params)</code> method instead, and supply an executor. The platform provides two executors for convenience, accessable as <code>AsyncTask.SERIAL_EXECUTOR</code> and <code>AsyncTask.THREAD_POOL_EXECUTOR</code> respectively. (Note: If you are targeting earlier API levels <code>executeOnExecutor</code> is not available, but you have several options - see below).</p>

<p>I have not tested exhaustively, but at least on tablets running HoneyComb the <code>THREAD_POOL_EXECUTOR</code> is set up with a maximum pool size of 128 and an additional queue length of 10. </p>

<p>If you exhaust the pool by submitting too many <code>AsyncTask</code>'s concurrently you will receive <code>RejectedExecutionException</code>'s - a subclass of RuntimeException which, unless handled, will crash your application. </p>

<p>I suspect that on a resource-constrained device it is probably quite a disaster if you actually have that many <code>AsyncTask</code>'s active concurrently - context-switching all those threads will render the cpu-cache ineffective, cost a lot in terms of CPU time, and anyway all those concurrently active threads will likely be using a good chunk of your heap and generating garbage for the GC to contend with.</p>

<p>You might want to consider an alternative <code>Executor</code> configured with a lower max threads and a longer queue, or a more appropriate strategy for managing the background work: for example if you have many files to download you could enqueue a url and a callback to a download-manager instead of executing an <code>AsyncTask</code> for each one.</p>

<h3>executeOnExecutor for API levels below 11</h3>

<p>AsyncTask gained a nice new method at API level 11 - <code>executeOnExecutor</code> - allowing you some control of the concurrency of your <code>AsyncTask</code>'s. If you need to support older API levels you have a choice to make: do you absolutely have to have <code>executeOnExecutor</code>, or do you simply want to use it when it is available, and fall-back to <code>execute</code> otherwise?</p>

<h4>The fallback approach</h4>

<p>If you want a simple way to take some measure of control where possible, you can subclass AsyncTask, test for the API level at runtime, and invoke the executeOnExecutor method if it is available - something like this:</p>

<pre><code>class MyAsyncTask&amp;lt;Param, Progress, Result&gt; {

    private static final boolean API_LEVEL_11 
        = android.os.Build.VERSION.SDK_INT &gt; 11;

    public void execute(Executor aExecutor, Params... aParams) {     
        if(API_LEVEL_11)
            executeOnExecutor(aExecutor, aParams); 
        else
            super.execute(aParams);
    }

}
</code></pre>

<p>I know that at first glance something appears wrong here:</p>

<pre><code>private static final boolean API_LEVEL_11 
    = android.os.Build.VERSION.SDK_INT &gt; 11;
</code></pre>

<p>This <em>looks</em> like it will be optimised out by the compiler - a static comparison of a literal integer (11) with what appears to be another static integer (android.os.Build.VERSION.SDK<em>INT), but in fact the upper-case VERSION.SDK</em>INT is slightly misleading - the values in VERSION are extracted at runtime from system properties, so the comparison is not baked in at compile-time.</p>

<h4>executeOnExecutor for all API levels</h4>

<p>If you insist on having executeOnExecutor available for all API levels you might try this: copy the code for AsyncTask from API level 15, rename it (and make a few small changes as described <a href="http://stackoverflow.com/questions/7211684/asynctask-executeonexecutor-before-api-level-11">here</a>), and use that everywhere in place of the SDK version.</p>

<h3>AsyncTask and the Activity lifecycle</h3>

<p>The <code>Activity</code> lifecycle is well defined and provides template methods which are invoked when critical events occur in the life of an <code>Activity</code>. </p>

<p><code>AsyncTask</code>'s are started by an <code>Activity</code> because it needs some potentially blocking work done off the UI thread, and unless you <em>really really know what you are doing</em> they should live and die with that <code>Activity</code>.</p>

<p>If your <code>AsyncTask</code> retains a reference to the <code>Activity</code>, not cancelling the task when the <code>Activity</code> dies wastes CPU resources on work that cannot update its UI, and creates a memory leak (the <code>Activity</code> and all its <code>View</code> hierarchy will be retained <em>until the task completes</em>). </p>

<p>Don't forget that the Activity is destroyed and re-created even on something as simple as a device orientation change, so if a user rotates their device you will have two copies of your Activity retained until the last <code>AsyncTask</code> completes. In a memory constrained environment this can be a disaster!</p>

<p>If you do not intend to update the UI after processing you <em>may</em> be using the wrong construct in some cases - consider whether using a Service would be more appropriate.</p>

<p>For some useful discussion and ideas related to <code>AsyncTask</code> and lifecycle management, see <a href="http://stackoverflow.com/questions/3357477/is-asynctask-really-conceptually-flawed-or-am-i-just-missing-something">this stackoverflow post</a>.</p>

<h4>AsyncTask and good Android citizenship</h4>

<p><code>AsyncTask</code> is in the SDK because it fulfils a common need, but it does not enforce a usage pattern that makes your app a good Android citizen.</p>

<p>In an environment where users switch contexts frequently and quickly (example: receive a phone call while in the midst of writing an email on your phone), it is probably important that your app does not hog resources whilst it is not the current focus.</p>

<p>If, as described above, you've set yourself up to cancel tasks according to the Activity lifecycle methods then you're all set and should not face any issues here.</p>
</span>

              <ul class="keywords">
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=Android">Android</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=AsyncTask">AsyncTask</a></li>
                  <li><a itemprop="keywords" href="http://www.google.com/search?q=site:steveliles.github.com&q=Threads">Threads</a></li>
              </ul>
              <div style="clear:both"></div>

	        <a href="android_s_asynctask.html">Comment on this post</a>

            </div>
        </div>
        <div class="sidebar">
          <div>
            <div class="twitter-feed" show="4" account="steveliles">
              <h5>Recent Tweets</h5>            
              <ul class="tweets">
                <li class="tweet-template" style="display:none">        
                  <span class="text"></span>&nbsp;<span class="date" format="yyyy"></span>
                </li>
              </ul>
              <a href="https://twitter.com/steveliles" class="twitter-follow-button" data-show-count="false">Follow @steveliles</a>
	      <script src="//platform.twitter.com/widgets.js" type="text/javascript"></script>
            </div>
          </div>
          <div>
            <a href="article-archive.html"><h5>Recent Posts</h5></a>
            <ul>
                <li><a href="roman_numeral_conversion_in_clojure_part_ii.html">Roman numeral conversion in Clojure, part II</a><span class="date"> - Mar 03, 2013</span></li>
                <li><a href="roman_numeral_conversion_in_clojure.html">Roman numeral conversion in Clojure</a><span class="date"> - Feb 28, 2013</span></li>
                <li><a href="gwt_i18n_using_browser_locale.html">GWT i18n using browser locale</a><span class="date"> - Feb 27, 2013</span></li>
                <li><a href="cross_domain_inter_frame_communication_in_javascript.html">Cross-domain inter-frame communication in javascript</a><span class="date"> - Feb 05, 2013</span></li>
                <li><a href="subversion_1_7_eclipse_integration_in_ubuntu_12.html">Subversion 1.7 Eclipse integration in Ubuntu 12</a><span class="date"> - Nov 13, 2012</span></li>
            </ul>
            <a href="article-archive.html">Older posts...</a>
          </div>
        </div>
      </div>
      <div class="nav">
        <div class="links">
          <div class="prev"><a title="previous" href="index_2.html">Newer Posts</a></div>
          <div class="next"><a title="next" href="index_4.html">Older Posts</a></div>
        </div>
      </div>
    </div>
    <script type="text/javascript" language="javascript" src="blog/blog.nocache.js"></script>
  </body>
</html>

